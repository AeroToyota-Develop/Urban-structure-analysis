"""
/***************************************************************************
 PlateauStatisticsVisualizationPlugin
                                 A QGIS plugin
 Urban Structure Assessment Dashboard
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-08-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Author
        email                : mail
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from __future__ import annotations

import os
import re
import xml.etree.ElementTree as ET
from distutils.util import strtobool # pylint: disable=deprecated-module

import numpy as np

import pandas as pd
from PyQt5.QtCore import QTimer # pylint: disable=import-error, no-name-in-module
from PyQt5.QtWidgets import QScrollArea, QVBoxLayout, QWidget # pylint: disable=import-error, no-name-in-module
from qgis.PyQt.QtCore import QCoreApplication, Qt, pyqtSignal # pylint: disable=import-error
from qgis.PyQt.QtWidgets import (QComboBox, QDockWidget, # pylint: disable=import-error
                                 QGroupBox, QLabel, QPushButton, QTabWidget)

import matplotlib.pyplot as plt
from matplotlib import colors as mcolors
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.ticker import FuncFormatter

from ..utils.LayersColoring import LayersColoring

# 定数定義
MINIMUM_WIDTH = 400  # 最小幅（ピクセル）
DEFAULT_HEIGHT = 300  # 固定高さ（ピクセル）
ASPECT_RATIO_DEFAULT = 4/3  # 通常レイアウトのアスペクト比（4:3）
ASPECT_RATIO_WIDE = 2/1     # 横長レイアウトのアスペクト比（2:1）

plt.rcParams['font.family'] = "MS Gothic"
_config_dir = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), '../config'
)
_config_file = os.path.join(_config_dir, 'VisualizationConfig.xml')
_config_file_custom = os.path.join(_config_dir, 'VisualizationConfigCustom.xml')
_revised_area_config_file = os.path.join(_config_dir, 'RevisedAreaVisualizationConfig.xml')
_datalist_file = os.path.join(_config_dir, 'DataListConfig.xml')
_color_file = os.path.join(_config_dir, 'GraphColorConfig.xml')
_default_colors = list(
    dict(mcolors.TABLEAU_COLORS, **mcolors.CSS4_COLORS).keys()
)

def safe_find(element, tag, default=''):
    """
    XML内の要素を安全に検索し、見つからない場合はデフォルト値を返す

    :param element: XMLの親要素
    :type element: xml.etree.ElementTree.Element
    :param tag: 検索するタグ名
    :type tag: str
    :param default: 見つからない場合のデフォルト値
    :type default: str

    :return: 検索されたタグの値、またはデフォルト値
    :rtype: str
    """
    found = element.find(tag)
    return found.text if found is not None else default

def check_virtual_flag(csv_path, column_name):
    """
    指定されたCSVファイルの指定された列の値をチェックし、0/1を判定する（時系列データ対応）

    :param csv_path: CSVファイルのパス
    :type csv_path: str
    :param column_name: チェックする列名
    :type column_name: str
    :return: 0なら真（仮想）、1なら偽（非仮想）、エラーなら偽
    :rtype: bool
    """
    if not csv_path or not column_name:
        return False

    try:
        df = pd.read_csv(csv_path)

        if column_name not in df.columns:
            print(f"Warning: Column '{column_name}' not found in {csv_path}")
            return False

        # 最新年（最後の行）の値をチェック
        value = df[column_name].iloc[-1]

        # 0なら仮想（True）、1なら非仮想（False）
        is_virtual = (int(value) == 0)
        print(f"Debug: Virtual check - CSV: {csv_path}, Column: {column_name}, Value: {value} (latest row), IsVirtual: {is_virtual}")
        return is_virtual

    except Exception as e:
        print(f"Error checking virtual flag: {e}")
        return False


def load_config(datalist_file, config_file, config_file_custom=None):
    """
    XMLファイルから設定を読み込む（カスタム設定ファイルがある場合は優先）

    :param datalist_file: データリストXMLファイルのパス
    :type datalist_file: str
    :param config_file: デフォルト設定XMLファイルのパス
    :type config_file: str
    :param config_file_custom: カスタム設定XMLファイルのパス（オプション）
    :type config_file_custom: str, optional

    :return: データ項目、年リスト、データセット
    :rtype: tuple[dict, list, dict]
    """
    dataList_tree = ET.parse(datalist_file)
    dataList_root = dataList_tree.getroot()

    data_items = {}
    for item in dataList_root.find('data_items').findall('item'):
        main_label = item.find('label').text
        sub_items = {}
        sub_items_elem = item.find('sub_items')
        if sub_items_elem is not None:
            for sub_item in sub_items_elem.findall('sub_item'):
                sub_label = sub_item.find('label').text
                sub_value = sub_item.find('value').text
                sub_items[sub_label] = sub_value
        data_items[main_label] = sub_items

    years = [year.text for year in dataList_root.find('years')]

    # デフォルト設定を読み込み
    tree = ET.parse(config_file)
    root = tree.getroot()

    datasets = {}

    for dataset in root.find('datasets'):
        item_val = dataset.find('item_val').text
        layout = safe_find(dataset, 'layout', 'vertical')

        # 新しいlayout_groups形式をチェック
        layout_groups_elem = dataset.find('layout_groups')
        if layout_groups_elem is not None:
            layout_groups = []
            for group in layout_groups_elem.findall('group'):
                layout_groups.append({
                    'columns': int(safe_find(group, 'columns', '1')),
                    'rows': int(safe_find(group, 'rows', '1')),
                    'data_count': int(safe_find(group, 'data_count', '1'))
                })
            layout_config = {'groups': layout_groups}
        else:
            # 従来のlayout_config形式
            layout_config_elem = dataset.find('layout_config')
            layout_config = {
                'columns': int(safe_find(layout_config_elem, 'columns', '1')) if layout_config_elem is not None else 1,
                'rows': int(safe_find(layout_config_elem, 'rows', '1')) if layout_config_elem is not None else 1
            }

        datalist = []
        for data in dataset.find('datalist'):
            colors = []
            try:
                colors = (
                    safe_find(data, 'color', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            x_labels = []
            try:
                x_labels = (
                    safe_find(data, 'x_label', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            legends = []
            try:
                legends = (
                    safe_find(data, 'legends', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            g_pos = []
            try:
                g_pos_str = (
                    safe_find(data, 'g_pos', '').replace(' ', '').split(',')
                )
                g_pos = [int(x) for x in g_pos_str if x]
            except Exception:
                pass

            g_label = []
            try:
                g_label = (
                    safe_find(data, 'g_label', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            legends_label = []
            try:
                legends_label = (
                    safe_find(data, 'legends_label', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            legends_color = []
            try:
                legends_color = (
                    safe_find(data, 'legends_color', '').replace(' ', '').split(',')
                )
            except Exception:
                pass

            datalist.append({
                'title': safe_find(data, 'title', 'No Name'),
                'path': safe_find(data, 'path'),
                'type': safe_find(data, 'type', 'Percentbar'),
                'addline': safe_find(data, 'addline', 'false'),
                'x': safe_find(data, 'x'),
                'y': safe_find(data, 'y', '').split(','),
                'change_rates': safe_find(data, 'change_rates'),
                'bar_label_rotate': safe_find(
                    data, 'bar_label_rotate', 'false'
                ),
                'color': colors,
                'label_type': safe_find(data,'label_type', 'edge'),
                'label_format': safe_find(data,'label_format', '1'),
                'x_labels': x_labels,
                'is_display_legend': safe_find(
                    data, 'is_display_legend', 'false'
                ),
                'is_display_bar_label': safe_find(
                    data, 'is_display_bar_label', 'true'
                ),
                'x_name': safe_find(data, 'x_name', ''),
                'legends': legends,
                'is_display_edgecolor': safe_find(
                    data, 'is_display_edgecolor', 'false'
                ),
                'hatch': safe_find(data, 'hatch', 'none'),
                'is_percentage_display': safe_find(
                    data, 'is_percentage_display', 'false'
                ),
                'scale_to_percentage': safe_find(
                    data, 'scale_to_percentage', 'false'
                ),
                'g_pos': g_pos,
                'text_box_label':safe_find(data, 'text_box_label', ''),
                'text_box_color':safe_find(data, 'text_box_color', ''),
                'g_label': g_label,
                'legends_label': legends_label,
                'legends_color': legends_color,
                'fixed_range_0_to_100': safe_find(
                    data, 'fixed_range_0_to_100', 'false'
                ),
                'y_axis_decimal_places': safe_find(
                    data, 'y_axis_decimal_places', '0'
                ),

                # 補助線関連
                'hline_path': safe_find(data, 'hline_path', ''),
                'hline_rate': safe_find(data, 'hline_rate', '').split(',') if safe_find(data, 'hline_rate', '') else [],
                'hline_color': safe_find(data, 'hline_color', '').split(',') if safe_find(data, 'hline_color', '') else [],
                'hline_text': safe_find(data, 'hline_text', '').split(',') if safe_find(data, 'hline_text', '') else [],
                'hline_range': safe_find(data, 'hline_range', '').split(',') if safe_find(data, 'hline_range', '') else [],

                # 横長サイズ対応
                'wide_layout': safe_find(data, 'wide_layout', 'false'),
                # タイトル判定用設定
                'virtual_check_column': safe_find(data, 'virtual_check_column', '')
            })

        if item_val not in datasets:
            datasets[item_val] = {}
        datasets[item_val] = {
            'layout': layout, 
            'layout_config': layout_config, 
            'data': datalist
        }

    # カスタム設定ファイルがある場合は上書き
    if config_file_custom and os.path.exists(config_file_custom):
        print(f"Debug: Loading custom config from {config_file_custom}")
        try:
            custom_tree = ET.parse(config_file_custom)
            custom_root = custom_tree.getroot()

            for dataset in custom_root.find('datasets'):
                item_val = dataset.find('item_val').text
                layout = safe_find(dataset, 'layout', 'vertical')

                # 新しいlayout_groups形式をチェック
                layout_groups_elem = dataset.find('layout_groups')
                if layout_groups_elem is not None:
                    layout_groups = []
                    for group in layout_groups_elem.findall('group'):
                        layout_groups.append({
                            'columns': int(safe_find(group, 'columns', '1')),
                            'rows': int(safe_find(group, 'rows', '1')),
                            'data_count': int(safe_find(group, 'data_count', '1'))
                        })
                    layout_config = {'groups': layout_groups}
                else:
                    # 従来のlayout_config形式
                    layout_config_elem = dataset.find('layout_config')
                    layout_config = {
                        'columns': int(safe_find(layout_config_elem, 'columns', '1')) if layout_config_elem is not None else 1,
                        'rows': int(safe_find(layout_config_elem, 'rows', '1')) if layout_config_elem is not None else 1
                    }

                print(f"Debug: Custom config - item_val={item_val}, layout={layout}")
                datalist = []
                for data in dataset.find('datalist'):
                    colors = []
                    try:
                        colors = (
                            safe_find(data, 'color', '').replace(' ', '').split(',')
                        )
                    except Exception:
                        pass

                    x_labels = []
                    try:
                        x_labels = (
                            safe_find(data, 'x_label', '').replace(' ', '').split(',')
                        )
                    except Exception:
                        pass

                    legends = []
                    try:
                        legends = (
                            safe_find(data, 'legends', '').replace(' ', '').split(',')
                        )
                    except Exception:
                        pass

                    g_pos = []
                    try:
                        g_pos_str = (
                            safe_find(data, 'g_pos', '').replace(' ', '').split(',')
                        )
                        g_pos = [int(x) for x in g_pos_str if x]
                    except Exception:
                        pass

                    g_label = []
                    try:
                        g_label = (
                            safe_find(data, 'g_label', '').replace(' ', '').split(',')
                        )
                    except Exception:
                        pass

                    legends_label = []
                    try:
                        legends_label = (
                            safe_find(data, 'legends_label', '').replace(' ', '').split(',')
                        )
                    except Exception:
                        pass

                    legends_color = []
                    try:
                        legends_color = (
                            safe_find(data, 'legends_color', '').replace(' ', '').split(',')
                        )
                    except Exception:
                        pass

                    datalist.append({
                        'title': safe_find(data, 'title', 'No Name'),
                        'path': safe_find(data, 'path'),
                        'type': safe_find(data, 'type', 'Percentbar'),
                        'addline': safe_find(data, 'addline', 'false'),
                        'x': safe_find(data, 'x'),
                        'y': safe_find(data, 'y', '').split(','),
                        'change_rates': safe_find(data, 'change_rates'),
                        'bar_label_rotate': safe_find(
                            data, 'bar_label_rotate', 'false'
                        ),
                        'color': colors,
                        'label_type': safe_find(data,'label_type', 'edge'),
                        'label_format': safe_find(data,'label_format', '1'),
                        'x_labels': x_labels,
                        'is_display_legend': safe_find(
                            data, 'is_display_legend', 'false'
                        ),
                        'is_display_bar_label': safe_find(
                            data, 'is_display_bar_label', 'true'
                        ),
                        'x_name': safe_find(data, 'x_name', ''),
                        'legends': legends,
                        'is_display_edgecolor': safe_find(
                            data, 'is_display_edgecolor', 'false'
                        ),
                        'hatch': safe_find(data, 'hatch', 'none'),
                        'is_percentage_display': safe_find(
                            data, 'is_percentage_display', 'false'
                        ),
                        'scale_to_percentage': safe_find(
                            data, 'scale_to_percentage', 'false'
                        ),
                        'g_pos': g_pos,
                        'text_box_label':safe_find(data, 'text_box_label', ''),
                        'text_box_color':safe_find(data, 'text_box_color', ''),
                        'g_label': g_label,
                        'legends_label': legends_label,
                        'legends_color': legends_color,
                        'fixed_range_0_to_100': safe_find(
                            data, 'fixed_range_0_to_100', 'false'
                        ),
                        'y_axis_decimal_places': safe_find(
                            data, 'y_axis_decimal_places', '0'
                        ),

                        # 補助線関連
                        'hline_path': safe_find(data, 'hline_path', ''),
                        'hline_rate': safe_find(data, 'hline_rate', '').split(',') if safe_find(data, 'hline_rate', '') else [],
                        'hline_color': safe_find(data, 'hline_color', '').split(',') if safe_find(data, 'hline_color', '') else [],
                        'hline_text': safe_find(data, 'hline_text', '').split(',') if safe_find(data, 'hline_text', '') else [],
                        'hline_range': safe_find(data, 'hline_range', '').split(',') if safe_find(data, 'hline_range', '') else [],

                        # 横長サイズ対応
                        'wide_layout': safe_find(data, 'wide_layout', 'false'),
                        # タイトル判定用設定
                        'virtual_check_column': safe_find(data, 'virtual_check_column', '')
                    })

                # カスタム設定で上書き
                datasets[item_val] = {
                    'layout': layout, 
                    'layout_config': layout_config, 
                    'data': datalist
                }
                print(f"Debug: Overwritten dataset {item_val} with layout={layout}, data_count={len(datalist)}")
        except Exception as e:
            print(f"Error loading custom config: {e}")

    # GraphColorManager の適用
    try:
        color_manager = GraphColorManager(_color_file, True)  # True=上書きモード
        overwrite_mode = True  # ← ここで TRUE/FALSE を切り替える
        color_manager.update_visualization_colors(datasets, overwrite_mode)
        print("Debug: GraphColorManagerによる色設定適用完了")
    except Exception as e:
        print(f"Warning: GraphColorManager適用エラー: {e}")

    return data_items, years, datasets


def format_number_1f(x):
    """
    小数点以下1桁で数値をフォーマットする

    :param x: フォーマットする数値
    :type x: float

    :return: フォーマットされた数値
    :rtype: str
    """
    return f'{x:.1f}'


def format_number_2f(x):
    """
    小数点以下2桁で数値をフォーマットする

    :param x: フォーマットする数値
    :type x: float

    :return: フォーマットされた数値
    :rtype: str
    """
    return f'{x:.2f}'


def format_number_hundred(x):
    """
    桁区切りで数値をフォーマットする

    :param x: フォーマットする数値
    :type x: int

    :return: フォーマットされた数値
    :rtype: str
    """
    return f'{x:,}'

def decimal_format(decimal_places, is_percentage_display = False, label_format = 1):
    """
    軸ラベルのformatter関数に小数点以下の桁数を渡す

    :param decimal_places: 小数点以下の桁数
    :type decimal_places: str
    :param is_percentage_display: パーセント表示するかどうか
    :type is_percentage_display: bool
    :param label_format: ラベルのフォーマット
    :type label_format: str

    :return: フォーマット関数
    :rtype: function
    """
    def format_axis(x, _):
        """
        軸ラベルをフォーマットする

        :param x: 軸ラベルの値
        :type x: float
        :param _: 使用されない引数
        :type _: Any

        :return: フォーマットされた軸ラベル
        :rtype: str
        """
        if is_percentage_display:
            return f'{x:.{decimal_places}f}%'
        elif label_format == '0':
            return f'{int(x):,}'
        else:
            return f'{x:.{decimal_places}f}'
    return format_axis

def is_1d_list(lst):
    """
    指定されたリストが1次元リストかどうかを確認する。

    :param lst: チェックするリスト
    :type lst: list

    :return: リストが1次元の場合はTrue、そうでない場合はFalse
    :rtype: bool
    """
    if not lst:
        return True

    return all(
        not isinstance(item, (list, tuple, np.ndarray, pd.Series))
        for item in lst
    )

class GraphColorManager:
    def __init__(self, graph_color_config_path, use_custom_colors=True):
        """
        GraphColorConfig.xmlを読み込んで色設定を管理するクラス

        Args:
            graph_color_config_path (str): GraphColorConfig.xmlのファイルパス
            use_custom_colors (bool): カスタム色を使用するかどうか
        """
        self.use_custom_colors = use_custom_colors
        self.color_config = self._load_graph_color_config(graph_color_config_path)

    def _load_graph_color_config(self, config_path):
        """
        GraphColorConfig.xmlを読み込んでitem_val毎の色設定を取得

        Returns:
            dict: {item_val: [color1, color2, color3], ...}
        """
        try:
            if not os.path.exists(config_path):
                print(f"GraphColorConfig.xmlが見つかりません: {config_path}")
                return {}

            tree = ET.parse(config_path)
            root = tree.getroot()

            color_config = {}

            # datasetタグの下のitem_valとdataをペアで読む
            dataset_elem = root.find('dataset')
            if dataset_elem is None:
                print("GraphColorConfig.xmlにdatasetタグが見つかりません")
                return {}

            current_item_val = None
            for child in dataset_elem:
                if child.tag == 'item_val':
                    current_item_val = int(child.text)
                elif child.tag == 'data' and current_item_val is not None:
                    color_element = child.find('color')
                    if color_element is not None:
                        # カンマ区切りの色文字列を分割してリストに変換
                        colors = [color.strip() for color in color_element.text.split(',')]
                        # '#'プレフィックスを追加（もし存在しない場合）
                        colors = [f'#{color}' if not color.startswith('#') else color for color in colors]
                        color_config[current_item_val] = colors
                        print(f"Debug: item_val={current_item_val}の色設定を読み込み: {colors}")
                        current_item_val = None

            print(f"Debug: GraphColorConfigから{len(color_config)}個の設定を読み込み")
            return color_config

        except Exception as e:
            print(f"GraphColorConfig.xml読み込みエラー: {e}")
            import traceback
            traceback.print_exc()
            return {}

    def update_visualization_colors(self, datasets, overwrite_mode=True):
        """
        VisualizationConfigのdatasetsの色設定を更新
        item_valをPKとして対応する色設定で上書き

        Args:
            datasets (dict): Visualizationのdatasets
            overwrite_mode (bool): 
                True  = 常にGraphColorConfigで上書き
                False = VisualizationConfigで未設定のときだけ補完
        """
        if not self.use_custom_colors or not self.color_config:
            print("Debug: カスタム色が無効またはカラー設定が空です")
            return

        print(f"Debug: {len(datasets)}個のデータセットを処理中、モード={'上書き' if overwrite_mode else '未設定時のみ設定'}")

        for dataset_key, dataset in datasets.items():
            try:
                item_val = int(dataset_key)
            except (ValueError, TypeError):
                print(f"Debug: dataset_key '{dataset_key}' を整数に変換できませんでした")
                continue

            custom_colors = self.color_config.get(item_val)
            if not custom_colors:
                print(f"Debug: item_val {item_val} に対応する色設定がありません")
                continue

            dataset_data = dataset if isinstance(dataset, list) else dataset.get('data', [])

            for data_idx, data_item in enumerate(dataset_data):
                # YearsbarはplotCatch時に_prepare_yearsbar_colors()で処理するのでここではスキップ
                if data_item.get('type') == 'Yearsbar':
                    print(f"Debug: Yearsbar data[{data_idx}] はplot時に処理するためスキップ")
                    continue

                # 通常のStackedbar/Seriesbar等の処理
                y_elements = data_item.get('y', '')
                if isinstance(y_elements, str) and y_elements:
                    y_list = [y.strip() for y in y_elements.split(',') if y.strip()]
                elif isinstance(y_elements, list):
                    y_list = y_elements
                else:
                    continue

                y_count = len(y_list)
                if y_count == 0:
                    continue

                existing_colors = data_item.get('color', [])
                if isinstance(existing_colors, str):
                    existing_colors = [c.strip() for c in existing_colors.split(',') if c.strip()]

                should_update = False
                if overwrite_mode:
                    should_update = True
                    print(f"Debug: data[{data_idx}] 上書きモードで色を更新")
                else:
                    if not existing_colors or all(not color for color in existing_colors):
                        should_update = True
                        print(f"Debug: data[{data_idx}] 未設定のため色を設定")

                if should_update:
                    graph_type = data_item.get('type', '')

                    if graph_type == 'MultiColorBar':
                        # MultiColorBarでは強制的に全色適用（y_countが1でも年数分の色が必要）
                        updated_colors = custom_colors  # 全色使用
                    elif graph_type == 'OverlappingBar':
                        # OverlappingBarでは強制的に全色適用（年数分の色が必要）
                        updated_colors = custom_colors  # 全色使用
                    else:
                        updated_colors = self._get_colors_by_graph_count(custom_colors, y_count)

                    data_item['color'] = updated_colors
                    print(f"Debug: data[{data_idx}] の色を更新完了 - y_count={y_count}, new_colors={updated_colors}")


    def _get_colors_by_graph_count(self, custom_colors, graph_count):
        """
        グラフの本数に応じて適切な色を選択

        Args:
            custom_colors (list): カスタム色のリスト
            graph_count (int): グラフの本数

        Returns:
            list: 更新された色のリスト
        """
        result_colors = []

        if graph_count == 2:
            # 2本の場合：1つ目をスキップして2つ目・3つ目の色を使用
            for i in range(graph_count):
                color_index = (i + 1) % len(custom_colors)  # インデックス1から開始
                result_colors.append(custom_colors[color_index])
            print(f"Debug: 2本グラフ - 1つ目をスキップ: {result_colors}")

        elif graph_count == 3:
            # 3本の場合：そのまま1つ目・2つ目・3つ目の色を使用
            for i in range(graph_count):
                color_index = i % len(custom_colors)
                result_colors.append(custom_colors[color_index])
            print(f"Debug: 3本グラフ - そのまま適用: {result_colors}")

        else:
            # その他の本数の場合：通常の循環処理
            for i in range(graph_count):
                color_index = i % len(custom_colors)
                result_colors.append(custom_colors[color_index])
            print(f"Debug: {graph_count}本グラフ - 通常処理: {result_colors}")

        return result_colors

class ControlDock(QDockWidget):
    """
    可視化を制御するためのdockwidget

    このDockWidgetは、可視化データの選択と実行を制御するためのユーザーインターフェースを提供します。
    メインプロット、修正区域タブ、サブプロットの3つの出力先に対応しています。

    属性:
        plotSignal (pyqtSignal): メインプロット更新用のシグナル（メイングラフタブと修正区域タブを同時更新）。
        plotSignal_second_tab (pyqtSignal): 修正区域タブ専用のシグナル。
        plotSignal_sub (pyqtSignal): サブプロット更新用のシグナル。

    メソッド:
        __init__(self, parent=None, translator=None): DockWidgetを初期化し、翻訳を設定します。
        setup_translator(translator): 国際化のための翻訳機能を設定します。
        setup_ui(): ユーザーインターフェースを設定します。
        update_sub_items(): メインアイテム(可視化データ選択)が選択されたときにサブアイテム(評価指標選択)を更新します。
        get_current_item_value(): 現在選択されているサブアイテム(評価指標選択)の`item_value`を取得する関数。
        get_current_sub_item_value():
            現在選択されているサブアイテム(参考評価指標選択)の`item_value`を取得する関数。
        emit_plot_signal(): プロットを更新するシグナルを発信します。
        emit_subplot_signal(): サブプロットを更新するシグナルを発信します。
    """
    plotSignal = pyqtSignal(str, str)
    plotSignal_second_tab = pyqtSignal(str)
    plotSignal_sub = pyqtSignal(str)

    def __init__(self, parent=None, translator=None):
        super().__init__(parent)
        self.setup_translator(translator)
        self.setWindowTitle(self.tr("Data Catalog"))
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.config_file = _config_file
        self.datalist_file = _datalist_file
        self.setup_ui()

    def setup_translator(self, translator):
        """
        国際化のための翻訳機能を設定します

        :param translator: 翻訳オブジェクト
        :type translator: QTranslator
        """
        if translator:
            QCoreApplication.installTranslator(translator)

    def setup_ui(self):
        """ユーザーインターフェースを設定します"""
        content = QWidget()
        layout = QVBoxLayout()

        self.data_items, self.years, _ = load_config(
            self.datalist_file, self.config_file, _config_file_custom
        )

        main_groupBox = QGroupBox()
        layout_main = QVBoxLayout()

        layout_main.addWidget(QLabel(self.tr('Select Visualization Data')))
        self.data_dropdown = QComboBox()
        self.data_dropdown.addItems(self.data_items.keys())
        self.data_dropdown.currentIndexChanged.connect(self.update_sub_items)
        layout_main.addWidget(self.data_dropdown)

        layout_main.addWidget(QLabel(self.tr('Select Sub Item')))
        self.sub_item_dropdown = QComboBox()
        layout_main.addWidget(self.sub_item_dropdown)

        layout_main.addWidget(QLabel(self.tr('Select Year')))
        self.year_dropdown = QComboBox()
        self.year_dropdown.addItems(self.years)
        layout_main.addWidget(self.year_dropdown)

        self.button = QPushButton(self.tr("Execute"))
        self.button.clicked.connect(self.emit_plot_signal)
        layout_main.addWidget(self.button)

        main_groupBox.setLayout(layout_main)
        layout.addWidget(main_groupBox)

        sub_groupBox = QGroupBox()
        layout_sub = QVBoxLayout()

        # 参考評価指標選択
        layout_sub.addWidget(QLabel(self.tr('Select Sub Graph Data')))
        self.sub_data_dropdown = QComboBox()
        self.sub_data_dropdown.addItems(self.data_items.keys())
        layout_sub.addWidget(self.sub_data_dropdown)

        self.button_sub = QPushButton(self.tr("Execute_sub"))
        self.button_sub.clicked.connect(self.emit_subplot_signal)
        layout_sub.addWidget(self.button_sub)

        sub_groupBox.setLayout(layout_sub)
        layout.addWidget(sub_groupBox)

        content.setLayout(layout)
        self.setWidget(content)

        self.update_sub_items()

    def update_sub_items(self):
        """メインアイテム(可視化データ選択)が選択されたときにサブアイテム(評価指標選択)を更新する関数"""
        self.sub_item_dropdown.clear()
        current_item = self.data_dropdown.currentText()
        if current_item in self.data_items:
            self.sub_item_dropdown.addItems(
                self.data_items[current_item].keys()
            )

    def get_current_item_value(self):
        """
        現在選択されているサブアイテム(評価指標選択)のitem_valueを取得する関数

        :return: 現在選択されているサブアイテムの値
        :rtype: str
        """
        main_item = self.data_dropdown.currentText()
        sub_item = self.sub_item_dropdown.currentText()
        return self.data_items[main_item][sub_item]

    def get_current_sub_item_value(self):
        """
        現在選択されているサブアイテム(参考評価指標選択)のitem_valueを取得する関数

        :return: 現在選択されているサブアイテムの値
        :rtype: str
        """
        main_item = self.sub_data_dropdown.currentText()
        return self.data_items[main_item][' ']

    def emit_plot_signal(self):
        """プロットを更新するシグナルを発信します"""
        self.plotSignal.emit(self.get_current_item_value(),
                             self.year_dropdown.currentText())

    def emit_subplot_signal(self):
        """サブプロットを更新するシグナルを発信します"""
        self.plotSignal_sub.emit(self.get_current_sub_item_value())


class GraphDock(QDockWidget):
    """
    グラフを表示するためのdockwidget

    このDockWidgetは、可視化グラフまたは比較グラフを表示するためのユーザーインターフェースを提供します。
    QGISアプリケーション内でフローティングまたはドッキング可能なパネルとして利用されます。
    title=0の場合はタブ機能付き（メイングラフ、修正区域）、title=1の場合はシンプル構造（サブプロット）です。

    属性:
        resize_timer (QTimer): ウィンドウのリサイズに遅延を加えてグラフサイズ調整を行うタイマー。
        content (QWidget): ダイアログのメインコンテンツ。
        layout (QVBoxLayout): メインレイアウト。
        tab_widget (QTabWidget): タブウィジェット（title=0の場合のみ）。
        main_tab (QWidget): メイングラフタブ（title=0の場合のみ）。
        revision_area_tab (QWidget): 修正区域タブ（title=0の場合のみ）。
        scroll_area (QScrollArea): メイングラフタブのスクロール領域。
        scroll_content (QWidget): メイングラフタブのスクロール領域内のコンテンツ。
        scroll_layout (QVBoxLayout): メイングラフタブのスクロール領域のレイアウト。
        revision_area_scroll_area (QScrollArea): 修正区域タブのスクロール領域（title=0の場合のみ）。
        revision_area_scroll_content (QWidget): 修正区域タブのスクロール領域内のコンテンツ（title=0の場合のみ）。
        revision_area_scroll_layout (QVBoxLayout): 修正区域タブのスクロール領域のレイアウト（title=0の場合のみ）。
        data_items (dict): 設定ファイルから読み込んだデータアイテム。
        datasets (dict): メイン設定ファイル（VisualizationConfig.xml + VisualizationConfigCustom.xml）から読み込んだデータセット。
        revised_area_datasets (dict): 修正区域用設定ファイル（RevisedAreaVisualizationConfig.xml）から読み込んだデータセット。
        color_manager (GraphColorManager): GraphColorConfig.xmlの色設定を管理するオブジェクト。
        layer_coloring (LayersColoring): レイヤーの色付けを担当するオブジェクト。

    メソッド:
        __init__(self, parent=None, translator=None, title=0):
            DockWidgetを初期化し、ウィンドウタイトルを設定します。
        setup_translator(translator): 国際化のための翻訳機能を設定します。
        setup_ui(): ユーザーインターフェースを設定します。
        check_colors(): デフォルトの色と指定された色をマージする機能。
        update_plots_and_layer_coloring(data_item, year): メイングラフタブと修正区域タブのプロットとレイヤーの色を更新します。
        update_plots(data_item): 選択されたデータ項目と年に基づいてメイングラフタブのプロットを更新します。
        update_revision_area_plots(data_item): 修正区域タブのプロットを更新します（RevisedAreaVisualizationConfig.xmlを使用）。
        create_vertical_plots_for_revision_area(datalist, target_layout): 修正区域タブ用の縦並びグラフを作成します。
        create_horizontal_plots_for_revision_area(datalist, layout_config, target_layout): 修正区域タブ用の横並びグラフを作成します。
        create_mixed_plots_for_revision_area(datalist, layout_config, target_layout): 修正区域タブ用のミックスレイアウトグラフを作成します。
        create_no_data_plot_for_revision_area(): 修正区域タブ用のデータなしプロットを作成します。
        title_check(text, df): テキスト内のプレースホルダを評価されたDataFrame式で置き換えます。
        plot_stacked_bar(ax, x, df, y_columns, add_line=False, colors=None,
                        change_rates=None, legends=None, bar_label_rotate=False,
                        label_type='edge', label_format='1',
                        is_display_bar_label=True):
            Stackedbarグラフをプロットします。
        plot_series_bar(ax, x, df, y_columns, add_line=False, colors=None,
                        change_rates=None,legends=None, bar_label_rotate=False,
                        label_type='edge', label_format='1',
                        is_display_bar_label=True):
            Seriesbarグラフをプロットします。
        plot_percent_bar(ax, x, df, y_columns, add_line=False, colors=None,
                        change_rates=None,legends=None, _bar_label_rotate=False,
                        is_display_bar_label=True):
            Percentbarグラフをプロットします。
        plot_years_bar(ax, df, data, colors,
                        label_type='edge', label_format='1',
                        is_display_bar_label=True):
            Yearsbarグラフをプロットします（複数年度データ用）。
        plot_single_year_bar(ax, df, data, colors, change_rates,
                        label_type='edge', label_format='1',
                        is_display_bar_label=True):
            SingleYearBarグラフをプロットします（特定年次データ用）。
        check_colors_yearsbar(years_data, colors):
            Yearsbarのみにデフォルトと指定された色をマージする機能。
        get_max_value(dict_values): 最大の数値を見つける関数。
        get_min_value(dict_values): 最小の数値を見つける関数。
        check_non_numeric_values(values): リスト内の非数値の値をチェックする関数。
        add_solid_line(ax, bars, y_bases=None): 棒グラフに実線を追加する関数。
        add_dashed_line(ax, bars, y_bases=None): 棒グラフに破線を追加する関数。
        resizeEvent(event): リサイズイベントを処理する関数。
        adjust_figure_sizes(): ウィジェットのサイズに基づいて図のサイズを調整する関数。
    """
    def __init__(self, parent=None, translator=None, title=0):
        super().__init__(parent)
        self.setup_translator(translator)
        self.title_type = title  # タブ機能の有無を判定するために保存
        if title == 0:
            self.setWindowTitle(self.tr('Visualization Graph'))
        else:
            self.setWindowTitle(self.tr('Comparison Graph'))
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.config_file = _config_file
        self.datalist_file = _datalist_file
        self.setup_ui()

        self.resize_timer = QTimer(self)
        self.resize_timer.setSingleShot(True)
        self.resize_timer.timeout.connect(self.adjust_figure_sizes)

    def setup_translator(self, translator):
        """
        国際化のための翻訳機能を設定します

        :param translator: 翻訳オブジェクト
        :type translator: QTranslator
        """
        if translator:
            QCoreApplication.installTranslator(translator)

    def setup_ui(self):
        """ユーザーインターフェースを設定します"""
        self.content = QWidget()
        self.layout = QVBoxLayout()
        self.content.setLayout(self.layout)
        self.setWidget(self.content)

        if self.title_type == 0:
            # graph_dock（title=0）の場合：現行・修正区域
            self.tab_widget = QTabWidget()
            self.layout.addWidget(self.tab_widget)

            # メインタブ
            self.main_tab = QWidget()
            main_layout = QVBoxLayout()
            self.main_tab.setLayout(main_layout)

            self.scroll_area = QScrollArea()
            self.scroll_content = QWidget()
            self.scroll_layout = QVBoxLayout()
            self.scroll_content.setLayout(self.scroll_layout)
            self.scroll_area.setWidget(self.scroll_content)
            self.scroll_area.setWidgetResizable(True)
            self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            main_layout.addWidget(self.scroll_area)

            # 修正区域タブ
            self.revision_area_tab = QWidget()
            revision_area_layout = QVBoxLayout()
            self.revision_area_tab.setLayout(revision_area_layout)

            self.revision_area_scroll_area = QScrollArea()
            self.revision_area_scroll_content = QWidget()
            self.revision_area_scroll_layout = QVBoxLayout()
            self.revision_area_scroll_content.setLayout(self.revision_area_scroll_layout)
            self.revision_area_scroll_area.setWidget(self.revision_area_scroll_content)
            self.revision_area_scroll_area.setWidgetResizable(True)
            self.revision_area_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.revision_area_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            revision_area_layout.addWidget(self.revision_area_scroll_area)

            # タブを追加
            self.tab_widget.addTab(self.main_tab, self.tr("メイングラフ"))
            self.tab_widget.addTab(self.revision_area_tab, self.tr("グラフ：修正区域"))

        else:
            # sub_graph_dock（title=1）の場合：参考グラフ
            self.scroll_area = QScrollArea()
            self.scroll_content = QWidget()
            self.scroll_layout = QVBoxLayout()
            self.scroll_content.setLayout(self.scroll_layout)
            self.scroll_area.setWidget(self.scroll_content)
            self.scroll_area.setWidgetResizable(True)
            self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.layout.addWidget(self.scroll_area)

        self.data_items, _, self.datasets = load_config(
            self.datalist_file, self.config_file, _config_file_custom
        )

        # 修正区域用の設定を読み込み
        self.revised_area_datasets = {}
        print(f"Debug: Checking RevisedAreaVisualizationConfig.xml at: {_revised_area_config_file}")
        if os.path.exists(_revised_area_config_file):
            print(f"Debug: RevisedAreaVisualizationConfig.xml exists, loading...")
            _, _, self.revised_area_datasets = load_config(
                self.datalist_file, _revised_area_config_file, None
            )
            print(f"Debug: Loaded revised_area_datasets: {list(self.revised_area_datasets.keys())}")
        else:
            print(f"Debug: RevisedAreaVisualizationConfig.xml does not exist, will use fallback")

        # GraphColorManagerを初期化
        self.color_manager = GraphColorManager(_color_file, True)

        # 色をチェック・適用（カスタム色対応版）
        self.check_colors_with_custom_config()

        # 修正区域用の色もメインと同じ方法でチェック・適用
        if self.revised_area_datasets:
            # 修正区域データもメインのcolor_managerで管理
            if self.color_manager:
                self.color_manager.update_visualization_colors(self.revised_area_datasets)

        self.layer_coloring = LayersColoring()

    def check_colors_with_custom_config(self, overwrite_mode=False):
        """
        GraphColorConfigの色を適用した色チェック処理

        Args:
            overwrite_mode (bool): 
                True  = 常にGraphColorConfigで上書き
                False = VisualizationConfigで未設定のときだけ補完
        """
        # GraphColorConfigの色を適用
        if self.color_manager:
            self.color_manager.update_visualization_colors(self.datasets, overwrite_mode)

        # 既存の色チェック処理（カスタム色を保護）
        for dataset in self.datasets.values():
            dataset_data = dataset if isinstance(dataset, list) else dataset.get('data', [])
            for data_list in dataset_data:
                # color文字列をリストに変換（カンマ区切りの場合）
                if isinstance(data_list['color'], str):
                    data_list['color'] = [c.strip() for c in data_list['color'].split(',')]

                # y要素も文字列の場合はリストに変換
                if isinstance(data_list['y'], str):
                    y_elements = [y.strip() for y in data_list['y'].split(',')]
                else:
                    y_elements = data_list['y']

                # MultiColorBarの場合は複数色を保持（y要素が1つでも年数分の色が必要）
                if data_list.get('type') != 'MultiColorBar' and len(y_elements) < len(data_list['color']):
                    data_list['color'] = data_list['color'][:len(y_elements)]

                # 色の長さを調整（GraphColorConfigの色を優先使用）
                for i in range(len(y_elements)):
                    if len(y_elements) > len(data_list['color']):
                        # GraphColorConfigから色を取得、なければデフォルト色
                        if hasattr(self, 'color_manager') and self.color_manager and self.color_manager.color_config:
                            # dataset_keyから対応するカスタム色を取得
                            dataset_key = None
                            for key, dataset in self.datasets.items():
                                dataset_data_check = dataset if isinstance(dataset, list) else dataset.get('data', [])
                                if data_list in dataset_data_check:
                                    try:
                                        dataset_key = int(key)
                                        break
                                    except (ValueError, TypeError):
                                        pass

                            if dataset_key is not None:
                                custom_colors = self.color_manager.color_config.get(dataset_key, [])
                                if custom_colors and len(data_list['color']) < len(custom_colors):
                                    data_list['color'].append(custom_colors[len(data_list['color']) % len(custom_colors)])
                                else:
                                    data_list['color'].append(_default_colors[i % len(_default_colors)])
                            else:
                                data_list['color'].append(_default_colors[i % len(_default_colors)])
                        else:
                            data_list['color'].append(_default_colors[i % len(_default_colors)])
                    elif data_list['color'][i] == '':
                        # 空文字列の場合のみデフォルト色で補完
                        data_list['color'][i] = _default_colors[i % len(_default_colors)]
                    # GraphColorConfigで設定された色は保護（_default_colorsにない色でも許可）

    def set_color_overwrite_mode(self, overwrite_mode):
        """
        色の上書きモードを設定して色を再適用?

        Args:
            overwrite_mode (bool):
                True  = 常にGraphColorConfigで上書き
                False = VisualizationConfigで未設定のときだけ補完
        """
        self.check_colors_with_custom_config(overwrite_mode)

    def check_colors(self):
        """デフォルトの色と指定された色をマージする機能"""
        for dataset in self.datasets.values():
            dataset_data = dataset if isinstance(dataset, list) else dataset.get('data', [])
            for data_list in dataset_data:
                # MultiColorBarの場合は複数色を保持（y要素が1つでも年数分の色が必要）
                if data_list.get('type') != 'MultiColorBar' and len(data_list['y']) < len(data_list['color']):
                    data_list['color'] = data_list['color'][
                        :len(data_list['y'])
                    ]
                for i in range(len(data_list['y'])):
                    if len(data_list['y']) > len(data_list['color']):
                        data_list['color'].append(_default_colors[i])
                    elif (
                        data_list['color'][i] == ''
                        or data_list['color'][i] not in _default_colors
                    ):
                        data_list['color'][i] = _default_colors[i]

    def update_plots_and_layer_coloring(self, data_item, year):
        """
        プロットとレイヤーの色を更新します

        :param data_item: 更新するデータ項目
        :type data_item: str
        :param year: 更新する年
        :type year: str
        """
        self.update_plots(data_item)
        # 修正区域タブがある場合のみ更新（title=0の場合のみ）
        if hasattr(self, 'revision_area_scroll_layout'):
            self.update_revision_area_plots(data_item)
        self.layer_coloring.coloring(data_item, year)

    def update_plots(self, data_item):
        """
        選択されたデータ項目と年に基づいてプロットを更新します

        :param data_item: 更新するデータ項目
        :type data_item: str
        """
        # current_item_valを設定（GraphColorManager用）
        try:
            self.current_item_val = int(data_item) if isinstance(data_item, (int, str)) else data_item
        except (ValueError, TypeError):
            self.current_item_val = data_item
        print(f"Debug: MainGraphDock - current_item_val set to {self.current_item_val}")

        for i in reversed(range(self.scroll_layout.count())):
            self.scroll_layout.itemAt(i).widget().setParent(None)

        if data_item in self.datasets:
            dataset = self.datasets[data_item]
            print(f"Debug: data_item={data_item}, dataset type={type(dataset)}")

            # 新しい形式（辞書）か旧形式（リスト）かを判定
            if isinstance(dataset, dict):
                datalist = dataset.get('data', [])
                layout = dataset.get('layout', 'vertical')
                layout_config = dataset.get('layout_config', {'columns': 1, 'rows': 1})
            else:
                datalist = dataset
                layout = 'vertical'
                layout_config = {'columns': 1, 'rows': 1}

            # レイアウトに応じて表示方法を選択
            if layout == 'horizontal' and len(datalist) >= 1:
                self.create_horizontal_plots(datalist, layout_config)
            elif layout == 'mixed' and len(datalist) >= 1:
                self.create_mixed_plots(datalist, layout_config)
            else:
                self.create_vertical_plots(datalist)
        else:
            self.create_no_data_plot()

        self.adjust_figure_sizes()

    def update_revision_area_plots(self, data_item):
        """
        修正区域タブのプロットを更新します（RevisedAreaVisualizationConfig.xmlの設定を使用）

        :param data_item: 更新するデータ項目
        :type data_item: str
        """
        # 修正区域タブのレイアウトをクリア
        for i in reversed(range(self.revision_area_scroll_layout.count())):
            self.revision_area_scroll_layout.itemAt(i).widget().setParent(None)

        # 使用するデータセットを決定
        datasets_to_use = None
        target_layout = self.revision_area_scroll_layout

        print(f"Debug: revision area - data_item={data_item}")
        print(f"Debug: revision area - revised_area_datasets keys={list(self.revised_area_datasets.keys()) if hasattr(self, 'revised_area_datasets') else 'None'}")
        print(f"Debug: revision area - main datasets keys={list(self.datasets.keys()) if hasattr(self, 'datasets') else 'None'}")

        # 修正区域用の設定が存在し、かつ該当データがある場合
        if hasattr(self, 'revised_area_datasets') and self.revised_area_datasets and data_item in self.revised_area_datasets:
            datasets_to_use = self.revised_area_datasets
            print(f"Debug: revision area - using revised_area_datasets")
        elif data_item in self.datasets:
            # 修正区域用の設定がない場合は、メイン設定をフォールバックとして使用
            datasets_to_use = self.datasets
            print(f"Debug: revision area - using main datasets as fallback")

        if datasets_to_use:
            dataset = datasets_to_use[data_item]

            # 新しい形式（辞書）か旧形式（リスト）かを判定
            if isinstance(dataset, dict):
                datalist = dataset.get('data', [])
                layout = dataset.get('layout', 'vertical')
                layout_config = dataset.get('layout_config', {'columns': 1, 'rows': 1})
            else:
                datalist = dataset
                layout = 'vertical'
                layout_config = {'columns': 1, 'rows': 1}

            # レイアウトに応じて表示方法を選択（メイングラフと同じロジック）
            if layout == 'horizontal' and len(datalist) >= 1:
                self.create_horizontal_plots_for_revision_area(datalist, layout_config, target_layout)
            elif layout == 'mixed' and len(datalist) >= 1:
                self.create_mixed_plots_for_revision_area(datalist, layout_config, target_layout)
            else:
                self.create_vertical_plots_for_revision_area(datalist, target_layout)
        else:
            self.create_no_data_plot_for_revision_area()

        self.adjust_figure_sizes()

    def create_vertical_plots_for_revision_area(self, datalist, target_layout):
        """
        修正区域タブ用の縦並びグラフを作成します

        メイングラフと全く同じ描画処理を使用し、グリッド線、色設定、レイアウトを統一します。

        :param datalist: プロットするデータのリスト
        :type datalist: list
        :param target_layout: グラフを追加する対象のレイアウト
        :type target_layout: QVBoxLayout
        """
        for data in datalist:
            is_wide_layout = self._get_wide_layout_flag(data)
            canvas_width, canvas_height, _ = self._calculate_canvas_size(is_wide_layout)

            figure = Figure(figsize=(canvas_width / 100, canvas_height / 100), dpi=100)
            canvas = FigureCanvas(figure)
            canvas.setMinimumSize(canvas_width, canvas_height)

            # データ情報をキャンバスに関連付け
            canvas.data_info = data
            target_layout.addWidget(canvas)

            ax = figure.add_subplot(111)
            ax.axhline(0, color='grey', linewidth=0.8)
            ax.set_axisbelow(True)
            ax.grid(True, axis='y', color='black', linestyle='--', linewidth=0.5, alpha=0.7)

            self.plot_single_graph(ax, data)
            figure.tight_layout()
            canvas.draw()
            self._adjust_legends_position(canvas)

    def create_horizontal_plots_for_revision_area(self, datalist, layout_config, target_layout):
        """
        修正区域タブ用の横並びグラフを作成します

        メイングラフと同じ横並びレイアウト処理を使用し、wide_layout対応やグリッド線を統一します。

        :param datalist: プロットするデータのリスト
        :type datalist: list
        :param layout_config: レイアウト設定（columns、rowsなど）
        :type layout_config: dict
        :param target_layout: グラフを追加する対象のレイアウト
        :type target_layout: QVBoxLayout
        """
        self.create_horizontal_plots_with_layout(datalist, layout_config, target_layout)

    def create_mixed_plots_for_revision_area(self, datalist, layout_config, target_layout):
        """
        修正区域タブ用のミックスレイアウトグラフを作成します

        メイングラフと同じミックスレイアウト処理を使用し、グループごとに異なるレイアウトを適用します。

        :param datalist: プロットするデータのリスト
        :type datalist: list
        :param layout_config: レイアウト設定（groupsの設定を含む）
        :type layout_config: dict
        :param target_layout: グラフを追加する対象のレイアウト
        :type target_layout: QVBoxLayout
        """
        self.create_mixed_plots_with_layout(datalist, layout_config, target_layout)

    def create_no_data_plot_for_revision_area(self):
        """
        修正区域タブ用のデータなしプロットを作成します

        データが見つからない場合に「No data available」メッセージを表示するプロットを作成します。

        :return: None
        :rtype: None
        """
        # メイングラフと同じサイズ計算を使用
        is_wide_layout = False  # no_data_plotは通常サイズ
        canvas_width, canvas_height, _ = self._calculate_canvas_size(is_wide_layout)

        figure = Figure(figsize=(canvas_width / 100, canvas_height / 100), dpi=100)
        canvas = FigureCanvas(figure)
        canvas.setMinimumSize(canvas_width, canvas_height)
        self.revision_area_scroll_layout.addWidget(canvas)

        ax = figure.add_subplot(111)
        ax.text(0.5, 0.5, 'No data available',
                horizontalalignment='center', verticalalignment='center',
                transform=ax.transAxes, fontsize=16)
        ax.set_xticks([])
        ax.set_yticks([])
        figure.tight_layout()
        canvas.draw()

    def create_horizontal_plots(self, datalist, layout_config):
        """
        横並びでグラフを作成する（wide_layout対応）

        :param datalist: データリスト
        :type datalist: list
        :param layout_config: レイアウト設定
        :type layout_config: dict
        """
        self.create_horizontal_plots_with_layout(datalist, layout_config, self.scroll_layout)

    def create_horizontal_plots_with_layout(self, datalist, layout_config, target_layout):
        """
        指定されたレイアウトに横並びグラフを作成します

        wide_layout対応を含む横並びレイアウトでグラフを作成し、指定されたレイアウトに追加します。
        メイングラフと修正区域タブの両方で使用される共通メソッドです。

        :param datalist: プロットするデータのリスト
        :type datalist: list
        :param layout_config: レイアウト設定（columns、rowsなど）
        :type layout_config: dict
        :param target_layout: グラフを追加する対象のレイアウト
        :type target_layout: QVBoxLayout
        """
        columns = layout_config.get('columns', 2)
        rows = layout_config.get('rows', 1)
        graphs_per_page = columns * rows

        i = 0
        while i < len(datalist):
            # 設定された数ずつペアにして処理
            data_group = datalist[i:i+graphs_per_page]

            # グループ内でwide_layoutがあるかチェック
            has_wide_layout = any(self._get_wide_layout_flag(data) for data in data_group)

            if has_wide_layout:
                # wide_layoutがある場合は個別にFigureを作成
                for data in data_group:
                    self._create_single_figure(data, target_layout)
            else:
                # 従来通り複数グラフを一つのFigureにまとめる
                self._create_combined_figure(data_group, columns, rows, target_layout)

            i += graphs_per_page

    def _create_single_figure(self, data, target_layout=None):
        """
        単一グラフ用のFigureを作成します

        wide_layoutフラグに基づいてキャンバスサイズを決定し、グリッド線付きのグラフを作成します。
        メイングラフと修正区域タブの両方で使用される共通メソッドです。

        :param data: プロットするデータの辞書
        :type data: dict
        :param target_layout: グラフを追加する対象のレイアウト（Noneの場合はself.scroll_layout）
        :type target_layout: QVBoxLayout or None
        """
        if target_layout is None:
            target_layout = self.scroll_layout

        is_wide_layout = self._get_wide_layout_flag(data)
        canvas_width, canvas_height, _ = self._calculate_canvas_size(is_wide_layout)

        figure_width_inch = canvas_width / 100  # ピクセル→インチ変換
        figure_height_inch = canvas_height / 100
        figure = Figure(figsize=(figure_width_inch, figure_height_inch), dpi=100)
        canvas = FigureCanvas(figure)
        canvas.setMinimumSize(canvas_width, canvas_height)

        # データ情報を関連付け
        canvas.data_info = data
        target_layout.addWidget(canvas)

        ax = figure.add_subplot(1, 1, 1)
        ax.axhline(0, color='grey', linewidth=0.8)
        ax.set_axisbelow(True)
        ax.grid(True, axis='y', color='black', linestyle='--', linewidth=0.5, alpha=0.7)

        self.plot_single_graph(ax, data)
        figure.tight_layout()
        canvas.draw()
        self._adjust_legends_position(canvas)

    def _get_wide_layout_flag(self, data):
        """wide_layoutフラグの値を取得"""
        if not data:
            return False

        wide_layout_str = data.get('wide_layout', 'false').lower()
        return wide_layout_str in ('true', '1', 'yes', 'on')

    def _calculate_canvas_size(self, is_wide_layout, viewport_width=None):
        """DEFAULT_HEIGHTベースで比率を保ったサイズを計算、MINIMUM_WIDTHで最小幅を保証"""

        # 基準高さはDEFAULT_HEIGHT
        base_height = DEFAULT_HEIGHT

        if is_wide_layout:
            # 横長レイアウト（2:1比率）
            default_width = int(base_height * ASPECT_RATIO_WIDE)  # 300 × 2 = 600px
            min_width = max(default_width, MINIMUM_WIDTH)  # 600px または 400 の大きい方

            if viewport_width and viewport_width > min_width:
                # viewportに合わせて比率を保ちながら拡大
                canvas_width = viewport_width
                canvas_height = int(canvas_width / ASPECT_RATIO_WIDE)  # 2:1比率を保持
            else:
                canvas_width = min_width
                canvas_height = int(canvas_width / ASPECT_RATIO_WIDE)  # 比率を保って高さ計算
        else:
            # 通常レイアウト（4:3比率）
            default_width = int(base_height * ASPECT_RATIO_DEFAULT)  # 300 × (4/3) = 400px
            min_width = max(default_width, MINIMUM_WIDTH)  # 400px または 400px の大きい方

            if viewport_width and viewport_width > min_width:
                # viewportに合わせて比率を保ちながら拡大
                canvas_width = viewport_width
                canvas_height = int(canvas_width / ASPECT_RATIO_DEFAULT)  # 4:3比率を保持
            else:
                canvas_width = min_width
                canvas_height = int(canvas_width / ASPECT_RATIO_DEFAULT)  # 比率を保って高さ計算

        return canvas_width, canvas_height, min_width

    def _create_combined_figure(self, data_group, columns, rows, target_layout=None):
        """
        複数グラフ用のFigureを作成します

        従来のロジックを使用して複数のグラフを一つのFigureにまとめて配置します。
        メイングラフと修正区域タブの両方で使用される共通メソッドです。

        :param data_group: プロットするデータのグループリスト
        :type data_group: list
        :param columns: グリッドの列数
        :type columns: int
        :param rows: グリッドの行数
        :type rows: int
        :param target_layout: グラフを追加する対象のレイアウト（Noneの場合はself.scroll_layout）
        :type target_layout: QVBoxLayout or None
        """
        subplot_rows = rows
        subplot_cols = columns

        # 従来のロジック
        min_width_per_graph = 5  # 最小幅（inch）
        min_height_per_graph = 4  # 最小高さ（inch）
        figure_width_inch = max(4 * subplot_cols, min_width_per_graph * subplot_cols)
        figure_height_inch = max(3 * subplot_rows, min_height_per_graph * subplot_rows)

        figure = Figure(figsize=(figure_width_inch, figure_height_inch), dpi=100)
        canvas = FigureCanvas(figure)
        canvas.setMinimumSize(int(figure_width_inch * 100), int(figure_height_inch * 100))

        # データ情報をキャンバスに関連付け（adjust_figure_sizes用）
        canvas.data_group = data_group
        if target_layout is None:
            target_layout = self.scroll_layout
        target_layout.addWidget(canvas)

        for j, data in enumerate(data_group):
            ax = figure.add_subplot(subplot_rows, subplot_cols, j+1)
            ax.axhline(0, color='grey', linewidth=0.8)
            ax.set_axisbelow(True)
            ax.grid(True, axis='y', color='black', linestyle='--', linewidth=0.5, alpha=0.7)
            self.plot_single_graph(ax, data)

        # データが足りない場合の空白処理
        graphs_per_page = columns * rows
        if len(data_group) < graphs_per_page:
            for k in range(len(data_group), graphs_per_page):
                ax = figure.add_subplot(subplot_rows, subplot_cols, k+1)
                ax.axis('off')

        figure.tight_layout()
        canvas.draw()
        self._adjust_legends_position(canvas)

    def create_mixed_plots(self, datalist, layout_config):
        """
        混合レイアウトでグラフを作成する（グループごとに異なるレイアウト）

        :param datalist: データリスト
        :type datalist: list
        :param layout_config: レイアウト設定
        :type layout_config: dict
        """
        self.create_mixed_plots_with_layout(datalist, layout_config, self.scroll_layout)

    def create_mixed_plots_with_layout(self, datalist, layout_config, target_layout):
        """
        混合レイアウトでグラフを作成する（グループごとに異なるレイアウト）

        :param datalist: データリスト
        :type datalist: list
        :param layout_config: レイアウト設定
        :type layout_config: dict
        :param target_layout: 追加先のレイアウト
        """
        if 'groups' not in layout_config:
            print("Debug: No groups found in layout_config, falling back to vertical")
            self.create_vertical_plots_for_revision_area(datalist, target_layout)
            return

        groups = layout_config['groups']
        data_index = 0

        for group_num, group in enumerate(groups):
            columns = group['columns']
            rows = group['rows']
            data_count = group['data_count']

            if data_index >= len(datalist):
                break

            # このグループで使用するデータを取得
            group_data = datalist[data_index:data_index + data_count]

            if len(group_data) == 0:
                continue

            # このグループ用のFigureを作成
            # 最小幅を保つため、columnsが多い場合でも十分なサイズを確保
            min_width_per_graph = 5  # 最小幅（inch）
            min_height_per_graph = 4  # 最小高さ（inch）
            figure_width = max(4 * columns, min_width_per_graph * columns)
            figure_height = max(3 * rows, min_height_per_graph * rows)
            figure = Figure(figsize=(figure_width, figure_height), dpi=100)
            canvas = FigureCanvas(figure)

            # キャンバスの最小サイズを設定して、小さくなりすぎないようにする
            canvas.setMinimumSize(int(figure_width * 100), int(figure_height * 100))
            target_layout.addWidget(canvas)

            # データをsubplotに配置
            for i, data in enumerate(group_data):
                ax = figure.add_subplot(rows, columns, i+1)
                ax.axhline(0, color='grey', linewidth=0.8)

                ax.set_axisbelow(True) # グリッドを背面に
                # グリッドを追加（横線のみ）
                ax.grid(True, axis='y', color='black', linestyle='--', linewidth=0.5, alpha=0.7)
                self.plot_single_graph(ax, data)

            # 空のサブプロットを追加（データが足りない場合）
            total_subplots = columns * rows
            if len(group_data) < total_subplots:
                for i in range(len(group_data), total_subplots):
                    ax = figure.add_subplot(rows, columns, i+1)
                    ax.axis('off')

            figure.tight_layout()
            canvas.draw()
            self._adjust_legends_position(canvas)
            data_index += data_count

    def create_vertical_plots(self, datalist):
        """
        縦に並べてグラフを作成する

        :param datalist: データリスト  
        :type datalist: list
        """
        for data in datalist:
            is_wide_layout = self._get_wide_layout_flag(data)
            canvas_width, canvas_height, _ = self._calculate_canvas_size(is_wide_layout)

            figure = Figure(figsize=(canvas_width / 100, canvas_height / 100), dpi=100)
            canvas = FigureCanvas(figure)
            canvas.setMinimumSize(canvas_width, canvas_height)

            # データ情報をキャンバスに関連付け（adjust_figure_sizes用）
            canvas.data_info = data
            self.scroll_layout.addWidget(canvas)

            ax = figure.add_subplot(111)
            ax.axhline(0, color='grey', linewidth=0.8)

            ax.set_axisbelow(True) # グリッドを背面に
            # グリッドを追加（横線のみ）
            ax.grid(True, axis='y', color='black', linestyle='--', linewidth=0.5, alpha=0.7)
            self.plot_single_graph(ax, data)
            figure.tight_layout()
            canvas.draw()
            self._adjust_legends_position(canvas)

    def create_no_data_plot(self):
        """
        データがない場合のプロットを作成する
        """
        figure = Figure(figsize=(4, 3), dpi=100)
        canvas = FigureCanvas(figure)
        self.scroll_layout.addWidget(canvas)
        ax = figure.add_subplot(111)
        ax.text(
            0.5,
            0.5,
            self.tr("No data available"),
            ha='center',
            va='center'
        )
        canvas.draw()

    def plot_single_graph(self, ax, data):
        """
        単一のグラフをプロットする

        :param ax: matplotlib axes
        :type ax: matplotlib.axes.Axes
        :param data: グラフデータ
        :type data: dict
        """
        df = pd.read_csv(data['path'])
        df = df.replace("―", "")
        x = None
        if data['type'] not in ['Yearsbar', 'SingleYearBar', 'RelationBar']:
            x = df[data['x']].to_numpy()
        y_columns = data['y']
        colors = data['color']

        # OverlappingBarで色が不足している場合の修正処理
        if data['type'] == 'OverlappingBar':
            if isinstance(colors, list) and len(colors) < 3:
                # OverlappingBarでは強制的に3色を設定
                # GraphColorConfig.xmlから直接読み込んで適用
                try:
                    color_manager = GraphColorManager(os.path.join(os.path.dirname(__file__), '..', 'config', 'GraphColorConfig.xml'), True)
                    # datasetsまたはrevised_area_datasetsからitem_valを動的に取得
                    item_val = None

                    # self.datasetsから検索
                    if hasattr(self, 'datasets') and self.datasets:
                        for key, dataset in self.datasets.items():
                            try:
                                dataset_data = dataset if isinstance(dataset, list) else dataset.get('data', [])
                                if data in dataset_data:
                                    item_val = int(key)
                                    break
                            except (ValueError, TypeError):
                                continue

                    # self.datasetsで見つからない場合、self.revised_area_datasetsから検索
                    if item_val is None and hasattr(self, 'revised_area_datasets') and self.revised_area_datasets:
                        for key, dataset in self.revised_area_datasets.items():
                            try:
                                dataset_data = dataset if isinstance(dataset, list) else dataset.get('data', [])
                                if data in dataset_data:
                                    item_val = int(key)
                                    break
                            except (ValueError, TypeError):
                                continue

                    # item_valが取得できない場合はデフォルト値を使用
                    if item_val is None:
                        item_val = 0

                    custom_colors = color_manager.color_config.get(item_val)
                    if custom_colors and len(custom_colors) >= 3:
                        colors = custom_colors
                except Exception:
                    pass

        # MultiColorBarとOverlappingBar専用：XMLの色をカンマ区切りで分割
        if data['type'] in ['MultiColorBar', 'OverlappingBar']:
            if isinstance(colors, str) and ',' in colors:
                colors = [c.strip() for c in colors.split(',') if c.strip()]
            elif isinstance(colors, list) and len(colors) == 1 and isinstance(colors[0], str) and ',' in colors[0]:
                colors = [c.strip() for c in colors[0].split(',') if c.strip()]

        change_rates = []
        if data['change_rates'] and data['change_rates'] != '':
            rate_columns = [
                col.strip() for col in data['change_rates'].split(',')
            ]
            for col in rate_columns:
                if col in df.columns:
                    change_rates.append(df[col].tolist())

        legends = []
        if (
            data['legends'] != [''] and
            len(data['legends']) != 0 and
            len(data['legends']) == len(y_columns)
        ):
            legends = data['legends']
        else:
            legends = y_columns

        add_line = strtobool(data['addline'])
        bar_label_rotate = strtobool(data['bar_label_rotate'])
        is_display_bar_label = strtobool(data['is_display_bar_label'])
        is_display_edgecolor = strtobool(data['is_display_edgecolor'])
        is_percentage_display = strtobool(data['is_percentage_display'])
        scale_to_percentage = strtobool(data['scale_to_percentage'])
        fixed_range_0_to_100 = strtobool(data['fixed_range_0_to_100'])

        # ハッチパターンの処理
        hatches = []
        if data['hatch'] and data['hatch'] != 'none':
            hatch_list = [h.strip() for h in data['hatch'].split(',')]
            for hatch in hatch_list:
                hatches.append(self.parse_hatch(hatch))

        # ハッチリストをy_columnsの長さに合わせる
        while len(hatches) < len(y_columns):
            hatches.append(None)

        # x軸の位置の処理
            g_pos = []
            if 'g_pos' in data and data['g_pos']:
                try:
                    g_pos = data['g_pos']
                except Exception as e:
                    g_pos = []

        if data['type'] == 'Stackedbar':
            # x_labelの処理
            x_label_list = []
            if 'x_label' in data and data['x_label']:
                try:
                    x_label_list = data['x_label'].split(',')
                except Exception:
                    x_label_list = []

            self.plot_stacked_bar(
                ax, x, df, y_columns, bool(add_line),
                colors, change_rates, legends,
                bar_label_rotate=bool(bar_label_rotate),
                label_type=data['label_type'],
                label_format=data['label_format'],
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                is_percentage_display=bool(is_percentage_display),
                scale_to_percentage=bool(scale_to_percentage),
                x_label=x_label_list,
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places']
            )
        elif data['type'] == 'Seriesbar':
            self.plot_series_bar(
                ax, x, df, y_columns, bool(add_line),
                colors, change_rates, legends,
                bar_label_rotate=bool(bar_label_rotate),
                label_type=data['label_type'],
                label_format=data['label_format'],
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                scale_to_percentage=bool(scale_to_percentage),
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places']
            )
        elif data['type'] == 'Percentbar':
            self.plot_percent_bar(
                ax, x, df, y_columns, bool(add_line),
                colors, change_rates, legends,
                _bar_label_rotate=bool(bar_label_rotate),
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                scale_to_percentage=bool(scale_to_percentage),
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places']
            )
        elif data['type'] == 'Yearsbar':
            # YearsbarでもGraphColorConfigの色を適用（本数ルール対応）
            years_bar_colors = self._prepare_yearsbar_colors(df, data, colors)
            self.plot_years_bar(
                ax, df, data, years_bar_colors,
                label_format=data['label_format'],
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                is_percentage_display=bool(is_percentage_display),
                scale_to_percentage=bool(scale_to_percentage),
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places']
            )
        elif data['type'] == 'SingleYearBar':
            # SingleYearBar用の色をGraphColorManagerから取得
            x_columns = data['x'].split(',')
            num_columns = len(x_columns)

            # GraphColorManagerから適切な色を取得
            if hasattr(self, 'color_manager') and self.color_manager and self.color_manager.color_config:
                item_val = getattr(self, 'current_item_val', None)
                print(f"Debug: SingleYearBar - current_item_val={item_val}")
                print(f"Debug: SingleYearBar - color_config keys={list(self.color_manager.color_config.keys())}")
                if item_val is not None and item_val in self.color_manager.color_config:
                    graph_colors = self.color_manager.color_config[item_val]
                    if num_columns == 2:
                        # 2個なら後半2つの色を使用
                        single_year_colors = graph_colors[-2:] if len(graph_colors) >= 2 else graph_colors
                    else:
                        # 全色使用
                        single_year_colors = graph_colors[:num_columns] if len(graph_colors) >= num_columns else graph_colors
                    print(f"Debug: SingleYearBar GraphColor適用 item_val={item_val}, 結果={single_year_colors}")
                else:
                    single_year_colors = colors
                    print(f"Debug: SingleYearBar GraphColor未適用, 元の色を使用={colors}")
            else:
                single_year_colors = colors
                print(f"Debug: SingleYearBar GraphColorManager未初期化, 元の色を使用={colors}")

            self.plot_single_year_bar(
                ax, df, data, single_year_colors,
                add_line=bool(add_line),
                change_rates=change_rates,
                label_type=data['label_type'],
                label_format=data['label_format'],
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                is_percentage_display=bool(is_percentage_display),
                scale_to_percentage=bool(scale_to_percentage),
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places']
            )
        elif data['type'] == 'MultiColorBar':
            self.plot_multi_color_bar(
                ax, x, df, y_columns, bool(add_line),
                colors, change_rates, legends,
                bar_label_rotate=bool(bar_label_rotate),
                label_type=data['label_type'],
                label_format=data['label_format'],
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                is_percentage_display=bool(is_percentage_display),
                scale_to_percentage=bool(scale_to_percentage),
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places'],
                g_pos = g_pos
            )
        elif data['type'] == 'OverlappingBar':
            self.plot_overlapping_bar(
                ax, x, df, y_columns, bool(add_line),
                colors, change_rates, legends,
                bar_label_rotate=bool(bar_label_rotate),
                label_type=data['label_type'],
                label_format=data['label_format'],
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                is_percentage_display=bool(is_percentage_display),
                scale_to_percentage=bool(scale_to_percentage),
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places']
            )
        elif data['type'] == 'RelationBar':
            # x_labelsの処理
            x_label_list = []
            if 'x_labels' in data and data['x_labels']:
                try:
                    x_label_list = data['x_labels']
                except Exception as e:
                    x_label_list = []

            # グラフに表示するカラム名の処理
            g_label = []
            if 'g_label' in data and data['g_label']:
                try:
                    g_label = data['g_label']
                except Exception as e:
                    g_label = []

            # 凡例のラベルの処理
            legends_label = []
            if 'legends_label' in data and data['legends_label']:
                try:
                    legends_label = data['legends_label']
                except Exception as e:
                    legends_label = []

            # 凡例の色の処理
            legends_color = []
            if 'legends_color' in data and data['legends_color']:
                try:
                    legends_color = data['legends_color']
                except Exception as e:
                    legends_color = []

            self.plot_relation_bar(
                ax, df, y_columns, bool(add_line),
                colors, change_rates, legends,
                bar_label_rotate=bool(bar_label_rotate),
                label_type=data['label_type'],
                label_format=data['label_format'],
                is_display_bar_label=bool(is_display_bar_label),
                is_display_edgecolor=bool(is_display_edgecolor),
                hatches=hatches,
                is_percentage_display=bool(is_percentage_display),
                scale_to_percentage=bool(scale_to_percentage),
                x_label=x_label_list,
                g_pos = g_pos,
                text_box_label = data['text_box_label'],
                text_box_color = data['text_box_color'],
                g_label = g_label,
                legends_label = legends_label,
                legends_color = legends_color,
                fixed_range_0_to_100=bool(fixed_range_0_to_100),
                y_axis_decimal_places=data['y_axis_decimal_places']
            )
        else:
            return

        # 横線の追加処理
        self.add_horizontal_lines(ax, data)


        if len(data['x_name']) != 0:
            _, x_max = ax.get_xlim()
            y_min, _ = ax.get_ylim()
            text_with_newlines = data['x_name'].replace(r'\n', '\n')
            ax.text(
                x_max + 0.1, y_min - 1.1,
                text_with_newlines, transform=ax.transData,
                fontsize=10, va='center'
            )

        # X軸目盛りラベルの設定（全てのグラフタイプに適用）
        # x_labelsを優先し、なければx_labelを使用
        x_label_setting = None
        if 'x_labels' in data and data['x_labels']:
            # x_labelsがある場合（リストまたはカンマ区切り文字列）
            if isinstance(data['x_labels'], list):
                x_label_setting = data['x_labels']
            else:
                x_label_setting = data['x_labels'].split(',') if data['x_labels'] else []
        elif 'x_label' in data and data['x_label']:
            # x_labelがある場合（カンマ区切り文字列）
            x_label_setting = data['x_label'].split(',') if data['x_label'] else []

        if x_label_setting:
            # 現在のX軸の目盛り数を取得
            current_ticks = ax.get_xticks()
            if len(x_label_setting) == len(current_ticks):
                ax.set_xticklabels(x_label_setting)

        data['title'] = self.title_check(data['title'], df)

        # 仮想フラグをチェックしてタイトルに「仮想」を付け足す
        try:
            virtual_csv = data.get('path')
            virtual_column = data.get('virtual_check_column', '')

            if virtual_csv and virtual_column:
                if check_virtual_flag(virtual_csv, virtual_column):
                    if not data['title'].startswith('仮想'):
                        data['title'] = f"仮想{data['title']}"
        except Exception as e:
            print(f"Error checking virtual flag for title: {e}")

        ax.set_title(data['title'], fontsize=10)

        ax.tick_params(axis='both', which='major', labelsize=10)

        is_display_legend = strtobool(data['is_display_legend'])
        if is_display_legend:
            ax.legend(
                fontsize=10,
                bbox_to_anchor=(0.5, -0.1),
                loc='upper center',
                borderaxespad=1,
                ncol=3
            )

    @staticmethod
    def title_check(text, df):
        """
        テキスト内のプレースホルダを評価されたDataFrame式で置き換えます。

        この関数は、特定のプレースホルダにマッチするパターンを識別し、評価された結果で置き換えます。
        `df[column][-1]` や `df[column].iloc[-1]` のような式をサポートしています。

        :param text: 評価対象のテキスト。
        :type text: str
        :param df: 置き換えに使用するDataFrame。
        :type df: pandas.DataFrame

        :returns: プレースホルダが置き換えられた後のテキスト。
        :rtype: str
        """
        def evaluator(match):
            expr = match.group(1)
            try:
                result = eval(expr, {'df': df}) # pylint: disable=W0123
                if isinstance(result, (int, float)):
                    return f"{result:.2f}"
                return str(result)
            except Exception as e:
                print(f"Error evaluating {expr}: {e}")
                return match.group(0)

        patterns = [
            r'\{(df\[[^\]]+\]\[-1\])\}',
            r'\{(df\[[^\]]+\]\.iloc\[-1\])\}',
        ]

        result = text
        for pattern in patterns:
            result = re.sub(pattern, evaluator, result)
        return result

    def plot_stacked_bar(self,
                         ax, x, df, y_columns,
                         add_line: bool = False,
                         colors: list = None,
                         change_rates: list = None,
                         legends: list = None,
                         bar_label_rotate = False,
                         label_type = 'edge',
                         label_format = '1',
                         is_display_bar_label = True,
                         is_display_edgecolor = False,
                         hatches: list = None,
                         is_percentage_display = False,
                         scale_to_percentage = False,
                         x_label = None,
                         fixed_range_0_to_100 = False,
                         y_axis_decimal_places='0'):
        """
        Stackedbarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type bar_label_rotate: bool
        :param label_type: ラベルの表示位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか（デフォルトはFalse）。
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト。
        :type hatches: list, optional
        :param is_percentage_display: パーセント表示するかどうか
        :type is_percentage_display: bool
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param x_label:x軸のラベルのリスト。
        :type x_label:list
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        """

        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []
        if hatches is None:
            hatches = []

        if is_1d_list(change_rates):
            change_rates = [change_rates]

        # ハイフン値を除外するためのフィルタリング
        valid_indices = []
        valid_x = []

        for i in range(len(x)):
            # 全ての系列でハイフン値でない場合のみ有効とする
            is_valid = True
            for y_col in y_columns:
                y_value = df[y_col].iloc[i]
                if pd.isna(y_value) or str(y_value).strip() == "―" or str(y_value).strip() == "":
                    is_valid = False
                    break
                try:
                    float(y_value)
                except (ValueError, TypeError):
                    is_valid = False
                    break

            if is_valid:
                valid_indices.append(i)
                valid_x.append(x[i])

        # 有効なデータがない場合は処理を終了
        if not valid_x:
            return

        bottom = np.zeros(len(valid_x))
        y_base = []
        for i, y_col in enumerate(y_columns):
            # 有効なインデックスのみの値を取得
            y_values = []
            for idx in valid_indices:
                value = float(df[y_col].iloc[idx])
                # scale_to_percentageがtrueの場合、実数も100倍
                if scale_to_percentage:
                    value *= 100
                y_values.append(value)
            y = pd.Series(y_values)
            # edgecolorの設定
            edgecolor = 'gray' if is_display_edgecolor else 'none'
            # ハッチパターンの設定
            hatch = hatches[i] if i < len(hatches) else None

            g = ax.bar(
                valid_x,
                y,
                bottom=bottom,
                width=2,
                color=colors[i],
                label=legends[i],
                edgecolor=edgecolor,
                linewidth=0.8,
                hatch=hatch
            )
            rotation = 0
            if bar_label_rotate:
                rotation = 90

            if is_display_bar_label:
                if is_percentage_display:
                    # パーセント表示の場合
                    ax.bar_label(
                        g,
                        labels=[f'{v:.1f}%' for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                elif label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )

            if add_line:
                _ = self.add_dashed_line(ax, g, y_base)
            bottom += y

            try:
                change_rate = change_rates[i]
                # 有効なインデックスに対応するchange_rateを取得
                valid_change_rates = []
                for idx in valid_indices:
                    if idx < len(change_rate):
                        valid_change_rates.append(change_rate[idx])
                    else:
                        valid_change_rates.append(None)

                for j, rate in enumerate(valid_change_rates):
                    if rate is not None and rate != "" and j > 0:  # 最初の要素はスキップ
                        try:
                            rate_float = float(rate)
                            # 現在の棒グラフと前の棒グラフの中間点にテキストを配置
                            x_pos = (valid_x[j - 1] + valid_x[j]) / 2
                            y_pos = (y[i - 1] + y[i]) / 2
                            ax.text(
                                x_pos,
                                y_pos,
                                f'{rate_float:+.1f}',
                                ha='center',
                                va='bottom',
                                fontsize=10
                            )
                        except ValueError:
                            pass
            except Exception:
                pass

        formatter = FuncFormatter(decimal_format(y_axis_decimal_places,
                                                 is_percentage_display,
                                                 label_format))

        ax.yaxis.set_major_formatter(formatter)
        ax.set_xticks(valid_x)
        ax.set_xticklabels(valid_x)

        # 積み上げグラフの場合、最大積み上げ値を計算（有効なデータのみ）
        stacked_max = 0
        stacked_min = 0
        for i in valid_indices:
            positive_sum = 0
            negative_sum = 0
            for col in y_columns:
                try:
                    value = float(df.iloc[i][col])
                    if value > 0:
                        positive_sum += value
                    elif value < 0:
                        negative_sum += value
                except (ValueError, TypeError):
                    continue
            stacked_max = max(stacked_max, positive_sum)
            stacked_min = min(stacked_min, negative_sum)

        # グラフの余白を設定
        self.set_y_axis_range_with_margin(ax, stacked_min, stacked_max, fixed_range_0_to_100)

        # X軸ラベルを設定（x_labelがある場合）
        if x_label and len(x_label) > 0:
            ax.set_xticklabels(x_label)

    def plot_series_bar(self,
                        ax, x, df, y_columns,
                        add_line: bool = False,
                        colors: list = None,
                        change_rates: list = None,
                        legends: list = None,
                        bar_label_rotate = False,
                        label_type = 'edge',
                        label_format = '1',
                        is_display_bar_label = True,
                        is_display_edgecolor = False,
                        hatches: list = None,
                        scale_to_percentage = False,
                        fixed_range_0_to_100 = False,
                        y_axis_decimal_places='0'):
        """
        Seriesbarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type bar_label_rotate: bool
        :param label_type: ラベルの表示位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか（デフォルトはFalse）。
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト。
        :type hatches: list, optional
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        """
        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []
        if hatches is None:
            hatches = []

        if is_1d_list(change_rates):
            change_rates = [change_rates]

        x_array = np.arange(len(x))
        width = 0.45
        for i, y_col in enumerate(y_columns):
            y = df[y_col]
            # edgecolorの設定
            edgecolor = 'gray' if is_display_edgecolor else 'none'
            # ハッチパターンの設定
            hatch = hatches[i] if i < len(hatches) else None

            g = ax.bar(
                x_array + i * width,
                y, width, color=colors[i],
                label=legends[i],
                edgecolor=edgecolor,
                linewidth=0.8,
                hatch=hatch
            )

            rotation = 0
            if bar_label_rotate:
                rotation = 90

            if is_display_bar_label:
                if label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
            if add_line:
                _ = self.add_dashed_line(ax, g)

            try:
                change_rate = change_rates[i]

                for j, rate in enumerate(change_rate):
                    if rate is not None and rate != "" and j > 0:  # 最初の要素はスキップ
                        try:
                            rate_float = float(rate)
                            # 現在のグループと前のグループの中間点にテキストを配置
                            x_pos = (x_array[j - 1] + x_array[j]) / 2
                            y_pos = (y[i - 1] + y[i]) / 2
                            ax.text(
                                x_pos,
                                y_pos,
                                f'{rate_float:+.1f}',
                                ha='center', va='bottom',
                                fontsize=10
                            )
                        except ValueError:
                            pass
            except Exception:
                pass

        formatter = FuncFormatter(decimal_format(y_axis_decimal_places,
                                                 label_format))
        ax.yaxis.set_major_formatter(formatter)
        ax.set_xticks(x_array + width * (len(y_columns) - 1) / 2)
        ax.set_xticklabels(x)

        max_value = df[y_columns].max().max()
        min_value = df[y_columns].min().min()

        # グラフの余白を設定
        self.set_y_axis_range_with_margin(ax, max_value, min_value, fixed_range_0_to_100)

    def plot_percent_bar(self,
                        ax, x, df, y_columns,
                        add_line: bool = False,
                        colors: list = None,
                        change_rates: list = None,
                        legends: list = None,
                        _bar_label_rotate=False,
                        is_display_bar_label=True,
                        is_display_edgecolor = False,
                        hatches: list = None,
                        scale_to_percentage = False,
                        fixed_range_0_to_100 = False,
                        y_axis_decimal_places='0'):
        """
        Percentbarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param _bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type _bar_label_rotate: bool
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか（デフォルトはFalse）。
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト。
        :type hatches: list, optional
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        """
        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []
        if hatches is None:
            hatches = []

        x_array = np.arange(len(x))
        width = 0.45
        for i, y_col in enumerate(y_columns):
            y = df[y_col].astype(float)
            y_full = np.full_like(x_array + i * width, 100)
            # edgecolorの設定
            edgecolor = 'gray' if is_display_edgecolor else 'none'
            # ハッチパターンの設定
            hatch = hatches[i] if i < len(hatches) else None

            ax.bar(
                x_array + i * width,
                y_full,
                color='gray',
                width=width,
                alpha=0.5,
                edgecolor=edgecolor
            )
            g = ax.bar(
                x_array + i * width,
                y,
                width,
                color=colors[i],
                label=legends[i],
                edgecolor=edgecolor,
                linewidth=0.8,
                hatch=hatch
            )
            if is_display_bar_label:
                ax.bar_label(g, label_type='center', padding=2, fmt='%d%%', fontsize=10)
            if add_line:
                _ = self.add_dashed_line(ax, g)
        if len(change_rates) > 0:
            for i, rate in enumerate(change_rates):
                if rate is not None and rate != "" and i > 0:  # 最初の要素はスキップ
                    try:
                        rate_float = float(rate)
                        # 現在の棒グラフと前の棒グラフの中間点にテキストを配置
                        x_pos = (x_array[i - 1] + x_array[i]) / 2
                        ax.text(
                            x_pos,
                            102,
                            f'{rate_float:+.1f}',
                            ha='center', va='bottom',
                            fontsize=10
                        )
                    except ValueError:
                        pass
        ax.set_xticks(x_array + width * (len(y_columns) - 1) / 2)
        ax.set_xticklabels(x)
        ax.set_ylabel(', '.join(y_columns) + '%')
        limit = 120
        ax.set_ylim(top=limit)

    def plot_years_bar(self, ax, df, data, colors,
                       label_type='edge',
                       label_format='1',
                       is_display_bar_label=True,
                       is_display_edgecolor=False,
                       hatches: list = None,
                       is_percentage_display=False,
                       scale_to_percentage=False,
                       fixed_range_0_to_100=False,
                       y_axis_decimal_places='0'):
        """
        Yearsbarグラフをプロットします（複数年度データ用）

        :param ax: グラフを描画する軸
        :type ax: matplotlib.axes.Axes
        :param df: プロットするデータのDataFrame
        :type df: pandas.DataFrame
        :param data: プロットに使用するデータ（x軸のラベル、y軸のカラム名など）
        :type data: dict
        :param colors: 各バーの色リスト
        :type colors: list
        :param label_type: ラベルの位置（デフォルトは'edge'）
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト
        :type hatches: list, optional
        :param is_percentage_display: パーセント表示するかどうか
        :type is_percentage_display: bool
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        """
        x_labels = data['x_labels']
        x_columns = data['x'].split(',')
        if hatches is None:
            hatches = []

        years_data = {}
        year_columns = [col for col in df.columns if col.lower() == 'year']

        # 存在する全ての年列に対して処理
        for year_col in year_columns:
            for year in df[year_col].unique().tolist():
                # 年でフィルタリングし、データを取得
                data_values = df[df[year_col] == year][x_columns].iloc[0].tolist()
                data_values = [
                    pd.to_numeric(value, errors='coerce')
                    for value in data_values
                ]
                # scale_to_percentageがtrueの場合、実数も100倍
                if scale_to_percentage:
                    data_values = [v * 100 if pd.notna(v) else v for v in data_values]
                years_data[year] = data_values

        # NaNまたは0の全ての値を持つ年を削除
        years_data = {
            year: values
            for year, values in years_data.items()
            if not (np.all(np.isnan(values)) or np.all(np.array(values) == 0))
        }

        width = 0.45
        gap = 0.2
        num_years = len(years_data)
        x = np.arange(len(x_labels)) * (width * num_years + gap)

        colors = self.check_colors_yearsbar(years_data, colors)

        for i, (year, values) in enumerate(years_data.items()):
            values_np = np.array(values)
            # edgecolorの設定
            edgecolor = 'gray' if is_display_edgecolor else 'none'
            # ハッチパターンの設定
            hatch = hatches[i] if i < len(hatches) else None

            g = ax.bar(
                x + i * width,
                np.nan_to_num(values_np),
                width,
                label=str(year),
                color=colors[i],
                edgecolor=edgecolor,
                linewidth=0.8,
                hatch=hatch
            )

            if is_display_bar_label:
                if scale_to_percentage:
                    # scale_to_percentageの場合、既に100倍されているのでそのまま使用
                    ax.bar_label(
                        g,
                        labels=[f'{v:.1f}%' for v in g.datavalues],
                        label_type=label_type, padding=2,
                        fontsize=10
                    )
                elif is_percentage_display:
                    # パーセント表示の場合
                    ax.bar_label(
                        g,
                        labels=[f'{v:.1f}%' for v in g.datavalues],
                        label_type=label_type, padding=2,
                        fontsize=10
                    )
                elif label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )

        # max_valueとmin_valueを計算
        max_value = self.get_max_value(years_data.values())
        min_value = self.get_min_value(years_data.values())

        formatter = FuncFormatter(decimal_format(y_axis_decimal_places,
                                                 is_percentage_display,
                                                 label_format))

        ax.yaxis.set_major_formatter(formatter)
        ax.set_xticks(x + width * (len(years_data) - 1) / 2)
        ax.set_xticklabels(x_labels)

        # グラフの余白を設定
        self.set_y_axis_range_with_margin(ax, min_value, max_value, fixed_range_0_to_100)

    def plot_single_year_bar(self, ax, df, data, colors,
                            add_line: bool = False,
                            change_rates: list = None,
                            label_type='edge',
                            label_format='1',
                            is_display_bar_label=True,
                            is_display_edgecolor=False,
                            hatches: list = None,
                            is_percentage_display=False,
                            scale_to_percentage=False,
                            fixed_range_0_to_100 = False,
                            y_axis_decimal_places='0'):
        """
        SingleYearBarグラフをプロットします（特定年次のデータのみ表示）

        :param ax: グラフを描画する軸
        :type ax: matplotlib.axes.Axes
        :param df: プロットするデータのDataFrame
        :type df: pandas.DataFrame
        :param data: プロットに使用するデータ（x軸のラベル、カラム名など）
        :type data: dict
        :param colors: 各バーの色リスト
        :type colors: list
        :param change_rates: 変化率リスト
        :type change_rates: list
        :param label_type: ラベルの位置（デフォルトは'edge'）
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト
        :type hatches: list, optional
        :param is_percentage_display: パーセント表示するかどうか
        :type is_percentage_display: bool
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        """
        x_labels = data['x_labels'] if 'x_labels' in data else data['x_label'].split(',')
        x_columns = data['x'].split(',')

        if hatches is None:
            hatches = []
        if change_rates is None:
            change_rates = []

        # データがある年を探す
        year_columns = [col for col in df.columns if col.lower() == 'year']
        data_year = None
        data_values = []

        print(f"Debug: SingleYearBar - x_columns={x_columns}")
        print(f"Debug: SingleYearBar - year_columns={year_columns}")
        print(f"Debug: SingleYearBar - df.columns={list(df.columns)}")
        print(f"Debug: SingleYearBar - df shape={df.shape}")

        for year_col in year_columns:
            print(f"Debug: SingleYearBar - checking year_col={year_col}")
            unique_years = df[year_col].unique()
            print(f"Debug: SingleYearBar - unique_years={unique_years}")

            for year in unique_years:
                print(f"Debug: SingleYearBar - checking year={year}")
                year_data = df[df[year_col] == year]
                print(f"Debug: SingleYearBar - year_data shape={year_data.shape}")

                if not year_data.empty:
                    row_data = year_data[x_columns].iloc[0].tolist()
                    print(f"Debug: SingleYearBar - row_data={row_data}")

                    # データがない（－や空文字）でない行を探す
                    valid_data = [str(val).strip() not in ["", "－", "-", "―", "nan"] and pd.notna(val) for val in row_data]
                    print(f"Debug: SingleYearBar - valid_data={valid_data}")

                    if any(valid_data):
                        print(f"Debug: SingleYearBar - Valid data found for year {year}")
                    else:
                        print(f"Debug: SingleYearBar - No valid data for year {year}, continuing to next year")

                    if any(valid_data):
                        data_year = year
                        # 数値に変換
                        data_values = [
                            pd.to_numeric(value, errors='coerce') if str(value).strip() not in ["", "－", "-", "―"]
                            else 0 for value in row_data
                        ]
                        # scale_to_percentageがtrueの場合、実数も100倍
                        if scale_to_percentage:
                            data_values = [v * 100 for v in data_values]
                        print(f"Debug: SingleYearBar - found data_year={data_year}, data_values={data_values}")
                        break
            if data_year:
                break

        print(f"Debug: SingleYearBar - final data_year={data_year}, data_values={data_values}")

        if not data_year or not data_values:
            # データがない場合は空のグラフ
            ax.text(0.5, 0.5, 'No data available', ha='center', va='center', transform=ax.transAxes)
            return

        # 色の調整：指定カラムが2つなら後半2つ、3つなら全色使用
        num_columns = len(x_columns)
        print(f"Debug: SingleYearBar - num_columns={num_columns}, original colors={colors}")

        if num_columns == 2:
            # 後半2つの色を使用
            if len(colors) >= 2:
                selected_colors = colors[-2:]
            else:
                selected_colors = colors
        else:
            # 全色使用
            selected_colors = colors[:num_columns] if len(colors) >= num_columns else colors

        # 色の数が足りない場合は繰り返し
        while len(selected_colors) < num_columns:
            selected_colors.extend(selected_colors)
        selected_colors = selected_colors[:num_columns]

        print(f"Debug: SingleYearBar - selected_colors={selected_colors}")
        print(f"Debug: SingleYearBar - data_values={data_values}")

        # 凡例の設定
        legends = data.get('legends', [])
        if legends and legends != ['']:
            # legendsが設定されている場合は使用
            legend_labels = legends
        else:
            # デフォルトはx_labels
            legend_labels = x_labels

        # バーグラフの描画
        width = 0.6
        x = np.arange(len(x_labels))

        edgecolor = 'gray' if is_display_edgecolor else 'none'

        # 各バーに凡例ラベルを設定
        bars = []
        for i, (x_pos, value, color, label) in enumerate(zip(x, data_values, selected_colors, legend_labels)):
            bar = ax.bar(
                x_pos,
                value,
                width,
                color=color,
                edgecolor=edgecolor,
                linewidth=0.8,
                hatch=hatches[i] if hatches and i < len(hatches) else (hatches[0] if hatches else None),
                label=label
            )
            bars.append(bar)

        # バーラベルの表示
        if is_display_bar_label:
            for i, bar in enumerate(bars):
                if scale_to_percentage:
                    # scale_to_percentageの場合、data_valuesは既に100倍されているのでそのまま使用
                    ax.bar_label(
                        bar,
                        labels=[f'{data_values[i]:.1f}%'],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )
                elif is_percentage_display:
                    ax.bar_label(
                        bar,
                        labels=[f'{data_values[i]:.1f}%'],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )
                elif label_format == '0':
                    ax.bar_label(
                        bar,
                        labels=[format_number_hundred(data_values[i])],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )
                elif label_format == '2':
                    ax.bar_label(
                        bar,
                        labels=[format_number_2f(data_values[i])],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )
                else:
                    ax.bar_label(
                        bar,
                        labels=[format_number_1f(data_values[i])],
                        label_type=label_type,
                        padding=2,
                        fontsize=10
                    )

        # addlineの処理
        line_y_positions = []
        if add_line:
            # barsをフラットなリストに変換
            flat_bars = [bar[0] for bar in bars]
            line_y_positions = self.add_dashed_line(ax, flat_bars)

        # change_ratesの表示
        print(f"Debug: SingleYearBar - change_rates={change_rates}")
        print(f"Debug: SingleYearBar - data_year={data_year}")

        if change_rates and len(change_rates) > 0:
            print(f"Debug: SingleYearBar - change_rates processing started")
            try:
                # CSVからchange_ratesデータを取得
                change_rate_columns = []
                print(f"Debug: SingleYearBar - change_rates[0] type: {type(change_rates[0])}")
                print(f"Debug: SingleYearBar - change_rates[0] content: {change_rates[0]}")

                # change_ratesが既に値のリストの場合（[['－', '-6.2']]のような形式）
                if isinstance(change_rates[0], list):
                    print(f"Debug: SingleYearBar - change_rates[0] is list, processing as values")
                    change_rate_columns = change_rates[0]
                    print(f"Debug: SingleYearBar - extracted change_rate_columns: {change_rate_columns}")
                elif isinstance(change_rates[0], str):
                    print(f"Debug: SingleYearBar - change_rates[0] is string: {change_rates[0]}")
                    # change_rates[0]がカラム名の場合、CSVから値を取得
                    change_rate_column = change_rates[0]
                    print(f"Debug: SingleYearBar - looking for column: {change_rate_column}")
                    print(f"Debug: SingleYearBar - available columns: {list(df.columns)}")

                    if change_rate_column in df.columns:
                        print(f"Debug: SingleYearBar - found change_rate_column in df")
                        # データがある年のchange_ratesを取得
                        if data_year is not None:
                            print(f"Debug: SingleYearBar - filtering by year: {data_year}")
                            year_row = df[df['year'] == data_year]
                            print(f"Debug: SingleYearBar - year_row shape: {year_row.shape}")

                            if not year_row.empty:
                                rate_value = year_row[change_rate_column].iloc[0]
                                print(f"Debug: SingleYearBar - raw rate_value: {rate_value}")
                                print(f"Debug: SingleYearBar - rate_value type: {type(rate_value)}")

                                if pd.notna(rate_value) and str(rate_value).strip() not in ["", "－", "-", "―"]:
                                    change_rate_columns = [rate_value]
                                    print(f"Debug: SingleYearBar - valid rate found: {change_rate_columns}")
                                else:
                                    print(f"Debug: SingleYearBar - rate_value is invalid")
                            else:
                                print(f"Debug: SingleYearBar - no data for year {data_year}")
                        else:
                            print(f"Debug: SingleYearBar - data_year is None")
                    else:
                        print(f"Debug: SingleYearBar - change_rate_column not found in df")
                else:
                    # その他の場合
                    change_rate_columns = change_rates[0] if is_1d_list(change_rates) else change_rates

                max_value = max(data_values) if data_values else 1

                # 各バーに対応する値がある場合、グラフとグラフの間に配置
                for i, rate in enumerate(change_rate_columns):
                    if i < len(x_labels) and rate is not None and str(rate).strip() not in ["", "－", "-", "―"]:  # 最初の要素はスキップ
                        try:
                            rate_float = float(rate)
                            print(f"rate_float:{rate_float}")
                            # scale_to_percentageがtrueの場合、実数も100倍
                            if scale_to_percentage:
                                rate_float *= 100
                            # 現在の棒グラフと前の棒グラフの中間点にテキストを配置
                            x_pos = (x[i - 1] + x[i]) / 2
                            y_pos = (data_values[i - 1] + data_values[i]) / 2
                            
                            ax.text(
                                x_pos,
                                y_pos,
                                f'{rate_float:+.1f}',
                                ha='center',
                                va='bottom',
                                fontsize=10,
                                color='black'
                            )
                        except (ValueError, TypeError):
                            pass

            except Exception as e:
                print(f"Warning: change_rates表示でエラー: {e}")

        # 軸の設定
        formatter = FuncFormatter(decimal_format(y_axis_decimal_places,
                                                 is_percentage_display,
                                                 label_format))

        ax.yaxis.set_major_formatter(formatter)
        ax.set_xticks(x)
        ax.set_xticklabels(x_labels)

        # 余白設定
        min_value = min(data_values) if data_values else 0
        max_value = max(data_values) if data_values else 1
        self.set_y_axis_range_with_margin(ax, min_value, max_value, fixed_range_0_to_100)

    def plot_multi_color_bar(self,
                            ax, x, df, y_columns,
                            add_line: bool = False,
                            colors: list = None,
                            change_rates: list = None,
                            legends: list = None,
                            bar_label_rotate = False,
                            label_type = 'edge',
                            label_format = '1',
                            is_display_bar_label = True,
                            is_display_edgecolor = False,
                            hatches: list = None,
                            is_percentage_display = False,
                            scale_to_percentage = False,
                            fixed_range_0_to_100 = False,
                            y_axis_decimal_places='0',
                            g_pos: list = None):
        """
        MultiColorBarグラフをプロットします（単一y軸で年ごとに異なる色）

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト（通常1つ）。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type bar_label_rotate: bool
        :param label_type: ラベルの表示位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか（デフォルトはFalse）。
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト。
        :type hatches: list, optional
        :param is_percentage_display: パーセント表示するかどうか
        :type is_percentage_display: bool
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        :param g_pos: グラフを表示するx軸の位置リスト。
        :type g_pos: list
        """

        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []
        if hatches is None:
            hatches = []

        if is_1d_list(change_rates):
            change_rates = [change_rates]

        # y軸は1つのみ想定
        y_column = y_columns[0] if y_columns else None
        if not y_column or y_column not in df.columns:
            return

        # ハイフン値を除外するためのフィルタリング（単一カラム用）
        valid_indices = []
        valid_x = []
        valid_y = []

        for i in range(len(x)):
            y_value = df[y_column].iloc[i]
            # ハイフン値をチェック（文字列として"―"またはpd.isna）
            if pd.isna(y_value) or str(y_value).strip() == "―" or str(y_value).strip() == "":
                continue  # ハイフン値の年はスキップ
            try:
                float_value = float(y_value)
                # scale_to_percentageがtrueの場合、実数も100倍
                if scale_to_percentage:
                    float_value *= 100
                valid_indices.append(i)
                valid_x.append(x[i])
                valid_y.append(float_value)
            except (ValueError, TypeError):
                continue  # 数値変換できない値もスキップ

        # 有効なデータがない場合は処理を終了
        if not valid_x:
            return

        # 色の設定（有効なデータ数に基づく）
        num_bars = len(valid_x)
        color_list = []

        if colors and len(colors) > 0:
            # 複数色が指定されている場合、有効なデータ分繰り返し適用
            for i, original_index in enumerate(valid_indices):
                color_list.append(colors[original_index % len(colors)])
        else:
            # 色が指定されていない場合はカラーマップを使用
            cm = plt.get_cmap("Spectral")
            color_positions = np.linspace(0.1, 0.9, num_bars)
            color_list = [cm(pos) for pos in color_positions]

        # edgecolorの設定
        edgecolor = 'gray' if is_display_edgecolor else 'none'

        # バーを描画（有効な年のみ）
        all_bars = []  # add_dashed_line用にバーをまとめて保存
        for i in range(num_bars):
            original_index = valid_indices[i]
            hatch = hatches[original_index] if original_index < len(hatches) else None
            if g_pos:
                g = ax.bar(
                    g_pos[i],
                    valid_y[i],
                    width=2,
                    color=color_list[i],
                    edgecolor=edgecolor,
                    linewidth=0.8,
                    hatch=hatch
                )
            else:
                g = ax.bar(
                    valid_x[i],
                    valid_y[i],
                    width=2,
                    color=color_list[i],
                    edgecolor=edgecolor,
                    linewidth=0.8,
                    hatch=hatch
                )
            all_bars.extend(g)  # バーをリストに追加

            rotation = 0
            if bar_label_rotate:
                rotation = 90

            if is_display_bar_label:
                if is_percentage_display:
                    # パーセント表示の場合
                    ax.bar_label(
                        g,
                        labels=[f'{v:.1f}%' for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                elif label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )

        # add_dashed_lineを使用した破線追加
        if add_line:
            _ = self.add_dashed_line(ax, all_bars)

        # change_ratesの表示（有効なデータのみ）
        try:
            change_rate = change_rates[0]
            valid_change_rates = []

            for i in valid_indices:
                if i < len(change_rate):
                    valid_change_rates.append(change_rate[i])
                else:
                    valid_change_rates.append(None)

            for j, rate in enumerate(valid_change_rates):
                if rate is not None and rate != "" and j > 0:  # 最初の要素はスキップ
                    try:
                        rate_float = float(rate)
                        # scale_to_percentageがtrueの場合、実数も100倍
                        if scale_to_percentage:
                            rate_float *= 100
                        x_pos = (valid_x[j - 1] + valid_x[j]) / 2
                        y_pos = (valid_y[j - 1] + valid_y[j]) / 2
                        ax.text(
                            x_pos,
                            y_pos,
                            f'{rate_float:+.1f}',
                            ha='center',
                            va='bottom',
                            fontsize=10
                        )
                    except ValueError:
                        pass
        except Exception:
            pass

        formatter = FuncFormatter(decimal_format(y_axis_decimal_places,
                                                        is_percentage_display,
                                                        label_format))

        ax.yaxis.set_major_formatter(formatter)
        if g_pos:
            ax.set_xticks(g_pos)
            ax.set_xticklabels(g_pos)
        else:
            ax.set_xticks(valid_x)
            ax.set_xticklabels(valid_x)

        # データの最大値・最小値を取得（有効なデータのみ）
        max_value = max(valid_y) if valid_y else 0
        min_value = min(valid_y) if valid_y else 0

        # グラフの余白を設定
        self.set_y_axis_range_with_margin(ax, min_value, max_value, fixed_range_0_to_100)

    def plot_overlapping_bar(self,
                            ax, x, df, y_columns,
                            add_line: bool = False,
                            colors: list = None,
                            change_rates: list = None,
                            legends: list = None,
                            bar_label_rotate = False,
                            label_type = 'edge',
                            label_format = '1',
                            is_display_bar_label = True,
                            is_display_edgecolor = False,
                            hatches: list = None,
                            is_percentage_display = False,
                            scale_to_percentage = False,
                            fixed_range_0_to_100 = False,
                            y_axis_decimal_places='0'):
        """
        重ね合わせバーグラフをプロットします（積み上げではなく、複数のバーを重ねて表示し、値が低い方を前面に配置）

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param x: x軸のラベル。
        :type x: list
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type bar_label_rotate: bool
        :param label_type: ラベルの表示位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか（デフォルトはFalse）。
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト。
        :type hatches: list, optional
        :param is_percentage_display: パーセント表示するかどうか
        :type is_percentage_display: bool
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        """

        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []
        if hatches is None:
            hatches = []

        if is_1d_list(change_rates):
            change_rates = [change_rates]

        y_base = []
        bars = []

        # 色の設定（既にXML解析時に分割済み）
        num_bars = len(x)
        color_list = []

        if colors and len(colors) > 0:
            # 複数色が指定されている場合、年数分繰り返し適用
            for i in range(num_bars):
                color_index = i % len(colors)
                selected_color = colors[color_index]
                color_list.append(selected_color)
        else:
            # 色が指定されていない場合はカラーマップを使用
            cm = plt.get_cmap("Spectral")
            color_positions = np.linspace(0.1, 0.9, num_bars)
            color_list = [cm(pos) for pos in color_positions]

        # 各列の平均値を計算して、値が高い順にソート
        column_averages = []
        for i, y_col in enumerate(y_columns):
            avg_value = df[y_col].mean()
            column_averages.append((i, y_col, avg_value))

        # 平均値の降順でソート（値が高い方から描画して背面に配置）
        column_averages.sort(key=lambda x: x[2], reverse=True)

        # ソートされた順序で各バーを描画
        for order_idx, (original_idx, y_col, _) in enumerate(column_averages):
            y = df[y_col]
            # edgecolorの設定
            edgecolor = 'gray' if is_display_edgecolor else 'none'

            # ハッチパターンの設定
            hatch = hatches[original_idx] if original_idx < len(hatches) else None

            g = ax.bar(
                x,
                y,
                width=2,
                color=color_list,
                label=legends[original_idx] if original_idx < len(legends) else None,
                edgecolor=edgecolor,
                linewidth=0.8,
                hatch=hatch,
                zorder=order_idx + 1  # 値が高い方ほど低いzorderで背面に配置
            )

            bars.append(g)

            rotation = 0
            if bar_label_rotate:
                rotation = 90

            if is_display_bar_label:
                if is_percentage_display:
                    # パーセント表示の場合
                    ax.bar_label(
                        g,
                        labels=[f'{v:.1f}%' for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                elif label_format == '0':
                    ax.bar_label(
                        g,
                        labels=[format_number_hundred(v) for v in g.datavalues],
                        label_type=label_type, padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                elif label_format == '2':
                    ax.bar_label(
                        g,
                        labels=[format_number_2f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )
                else:
                    ax.bar_label(
                        g,
                        labels=[format_number_1f(v) for v in g.datavalues],
                        label_type=label_type,
                        padding=2,
                        rotation=rotation,
                        fontsize=10
                    )

            if add_line:
                _ = self.add_dashed_line(ax, g, y_base)

            try:
                change_rate = change_rates[original_idx]

                for j, rate in enumerate(change_rate):
                    if rate is not None and rate != "" and j > 0:  # 最初の要素はスキップ
                        try:
                            rate_float = float(rate)
                            # 現在の棒グラフと前の棒グラフの中間点にテキストを配置
                            x_pos = (x[j - 1] + x[j]) / 2
                            y_pos = (y[i - 1] + y[i]) / 2
                            ax.text(
                                x_pos,
                                y_pos,
                                f'{rate_float:+.1f}',
                                ha='center',
                                va='bottom',
                                fontsize=10
                            )
                        except ValueError:
                            pass
            except Exception:
                pass

        formatter = FuncFormatter(decimal_format(y_axis_decimal_places,
                                                        is_percentage_display,
                                                        label_format))

        ax.yaxis.set_major_formatter(formatter)
        ax.set_xticks(x)
        ax.set_xticklabels(x)

        # データの最大値・最小値を取得
        max_value = df[y_columns].max().max()
        min_value = df[y_columns].min().min()

        # グラフの余白を設定
        self.set_y_axis_range_with_margin(ax, min_value, max_value, fixed_range_0_to_100)

    def plot_relation_bar(self,
                        ax, df, y_columns,
                        add_line: bool = False,
                        colors: list = None,
                        change_rates: list = None,
                        legends: list = None,
                        bar_label_rotate = False,
                        label_type = 'edge',
                        label_format = '1',
                        is_display_bar_label = True,
                        is_display_edgecolor = False,
                        hatches: list = None,
                        is_percentage_display = False,
                        scale_to_percentage = False,
                        x_label = None,
                        g_pos: list = None,
                        text_box_label = None,
                        text_box_color = None,
                        g_label = None,
                        legends_label = None,
                        legends_color = None,
                        fixed_range_0_to_100 = False,
                        y_axis_decimal_places='0'):
        """
        RelationBarグラフをプロットします

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param df: プロットするデータのDataFrame。
        :type df: pandas.DataFrame
        :param y_columns: y軸のカラム名リスト。
        :type y_columns: list
        :param add_line: グラフにラインを追加するかどうか（デフォルトはFalse）。
        :type add_line: bool
        :param colors: グラフのバーの色リスト。
        :type colors: list, optional
        :param change_rates: 変化率リスト。
        :type change_rates: list, optional
        :param legends: 各バーの凡例。
        :type legends: list, optional
        :param bar_label_rotate: バーラベルの回転を行うかどうか（デフォルトはFalse）。
        :type bar_label_rotate: bool
        :param label_type: ラベルの表示位置（デフォルトは'edge'）。
        :type label_type: str
        :param label_format: ラベルのフォーマット（デフォルトは'1'）。
        :type label_format: str
        :param is_display_bar_label: バーラベルを表示するかどうか（デフォルトはTrue）。
        :type is_display_bar_label: bool
        :param is_display_edgecolor: バーの縁の色を表示するかどうか（デフォルトはFalse）。
        :type is_display_edgecolor: bool
        :param hatches: ハッチパターンのリスト。
        :type hatches: list, optional
        :param is_percentage_display: パーセンテージを表示するかどうか（デフォルトはFalse）。
        :type is_percentage_display: bool
        :param scale_to_percentage: csvの数値をパーセントに変換するかどうか
        :type scale_to_percentage: bool
        :param x_label: x軸のラベルのリスト。
        :type x_label: list
        :param g_pos: グラフを表示するx軸の位置リスト。
        :type g_pos: list
        :param text_box_label: グラフ上に表示するテキストボックスのラベル
        :type text_box_label: str
        :param text_box_color: グラフ上に表示するテキストボックスの色
        :type text_box_color: str
        :param g_label: グラフ上に表示するテキストラベルのリスト
        :type g_label: list
        :param legends_label: 凡例のテキストラベルのリスト
        :type legends_label: list
        :param legends_color: 凡例ラインの色のリスト
        :type legends_color: list
        :param fixed_range_0_to_100: y軸目盛を0-100に設定するかどうか
        :type fixed_range_0_to_100: bool
        :param y_axis_decimal_places: y軸目盛の小数点以下の桁数
        :type y_axis_decimal_places: str
        """

        if colors is None:
            colors = []
        if change_rates is None:
            change_rates = []
        if legends is None:
            legends = []
        if hatches is None:
            hatches = []

        if is_1d_list(change_rates):
            change_rates = [change_rates]

        # グラフの本数を取得
        group_num = len(x_label)

        if g_pos is None:
            g_pos = range(group_num)

        # カラム数を取得
        column_num = len(y_columns)

        # 積み上げ数を取得
        stuck_num = column_num // group_num

        # 色の設定
        color_list = []
        if colors and len(colors) > 0:
            # 空文字列を除外
            valid_colors = [c for c in colors if c and str(c).strip() != '']
            for i in range(stuck_num):
                color_index = i % len(valid_colors)
                selected_color = valid_colors[color_index]
                color_list.append(selected_color)
        else:
            color_list = ['#A6A6A6', '#747474']

        all_bars = []
        max_group_value = []

        for group in range(group_num):
            start_idx = group * stuck_num
            end_idx = start_idx + stuck_num
            group_values = []
            # 各グループのy軸要素を取得
            group_columns = y_columns[start_idx:end_idx]
            adjusted_group_columns = []
            # グラフのx軸の位置を取得
            g_position = g_pos[group]
            is_valid = True
            for column in group_columns:
                adjusted_group_columns.append(column)
                # グループ内の各カラムからy値を取得
                # （IF107のcsvが1行しかないため0を指定）
                y_value = df[column].iloc[0]
                # 空白やハイフンのカラムを除外
                if pd.isna(y_value) or str(y_value).strip() == "―" or str(y_value).strip() == "":
                    is_valid = False
                    break
                try:
                    # 有効な値をリストに代入
                    y_value = float(y_value)
                    group_values.append(y_value)
                except (ValueError, TypeError):
                    is_valid = False
                    break
            if not is_valid:
                return

            group_columns = adjusted_group_columns
            group_bar = []

            if group_values:
                bottom = 0
                max_group_value.append(sum(group_values))
                for i, y_value in enumerate(group_values):
                    # edgecolorの設定
                    edgecolor = 'gray' if is_display_edgecolor else 'none'
                    # ハッチパターンの設定
                    hatch = hatches[i] if i < len(hatches) else None

                    g = ax.bar(
                        g_position,
                        y_value,
                        bottom=bottom,
                        width=1.5,
                        color=color_list[i],
                        edgecolor=edgecolor,
                        linewidth=0.8,
                        hatch=hatch
                    )
                    rotation = 0
                    if bar_label_rotate:
                        rotation = 90

                    if is_display_bar_label:
                        if is_percentage_display:
                            # パーセント表示の場合
                            ax.bar_label(
                                g,
                                labels=[f'{v:.1f}%' for v in g.datavalues],
                                label_type=label_type, padding=2,
                                rotation=rotation,
                                fontsize=10
                            )
                        elif label_format == '0':
                            ax.bar_label(
                                g,
                                labels=[format_number_hundred(v) for v in g.datavalues],
                                label_type=label_type, padding=2,
                                rotation=rotation,
                                fontsize=10
                            )
                        elif label_format == '2':
                            ax.bar_label(
                                g,
                                labels=[format_number_2f(v) for v in g.datavalues],
                                label_type=label_type,
                                padding=2,
                                rotation=rotation,
                                fontsize=10
                            )
                        else:
                            ax.bar_label(
                                g,
                                labels=[format_number_1f(v) for v in g.datavalues],
                                label_type=label_type,
                                padding=2,
                                rotation=rotation,
                                fontsize=10
                            )

                    bottom += y_value
                    group_bar.append(g)
            all_bars.append(group_bar)

        if add_line:
            _ = self.add_multiple_dashed_line(ax, all_bars)

        # change_ratesの表示（有効なデータのみ）
        try:
            change_rate = change_rates[0]
            valid_change_rates = []
            for i in range(group_num):
                if i < len(change_rate):
                    valid_change_rates.append(change_rate[i])
                else:
                    valid_change_rates.append(None)

            for j, rate in enumerate(valid_change_rates):
                if rate is not None and rate != "" and j > 0:  # 最初の要素はスキップ
                    try:
                        rate_float = float(rate)
                        # 現在の棒グラフと前の棒グラフの中間点にテキストを配置
                        x_pos = (g_pos[j - 1] + g_pos[j]) / 2
                        y_pos = (max_group_value[i - 1] + max_group_value[i]) / 2
                        ax.text(
                            x_pos,
                            y_pos,
                            f'{rate_float:+.1f}',
                            ha='center',
                            va='bottom',
                            fontsize=10
                        )
                    except ValueError:
                        pass
        except Exception:
            pass

        formatter = FuncFormatter(decimal_format(y_axis_decimal_places,
                                                        is_percentage_display,
                                                        label_format))
        ax.yaxis.set_major_formatter(formatter)
        ax.set_xticks(g_pos)
        ax.set_xticklabels(x_label)

        # 最大積み上げ値を取得
        stacked_max = max(max_group_value)
        stacked_min = 0

        # グラフの余白を設定
        self.set_y_axis_range_with_margin(ax, stacked_min, stacked_max, fixed_range_0_to_100)

        # X軸ラベルを設定（x_labelがある場合）
        if x_label and len(x_label) > 0:
            ax.set_xticklabels(x_label)

        # テキストボックスとそれに付随するラインの表示処理
        if text_box_label and text_box_color:
            # 最終グループの第一積み上げグラフ情報
            last_bar_container = all_bars[-1][0]
            last_bar = last_bar_container[0]
            bar_info = {
                'x' : g_pos[-1],
                'bar_right' : last_bar.get_x() + last_bar.get_width(),
                'y' : last_bar.get_y() + last_bar.get_height()
            }

            # テキストボックスの情報
            text_obj = {
                'text': text_box_label,
                'fontsize': 10,
                'color': 'black',
                'bbox': {
                    'facecolor': text_box_color,
                    'edgecolor': text_box_color,
                    'boxstyle': 'Square, pad=0.3',
                    'linewidth': 0.1
                }
            }

            # ラインの情報
            layout_config = {
                'color': text_box_color,
                'linewidth': 2
            }

            self.add_text_box_with_line(ax, bar_info, text_obj, layout_config)

        # カラム名をグラフ上に表示する処理
        if g_label:
            g_label_num = len(g_label)
            display_group = g_label_num // stuck_num
            for i in range(display_group):
                for j in range(stuck_num):
                    bar_container = all_bars[i][j]
                    bar = bar_container[0]
                    x = bar.get_x() + bar.get_width() / 2
                    bottom = bar.get_y()
                    height = bar.get_height() + bottom
                    y = (bottom + height) / 2
                    g_idx = i * stuck_num + j
                    ax.text(x, y, g_label[g_idx], ha='center', color='black', fontsize=10)

        # 凡例を表示する処理
        if legends_label and legends_color:
            self.add_legends_with_line(ax, legends_label, legends_color)

    def set_y_axis_range_with_margin(self, ax, min_value, max_value, fixed_range_0_to_100=False):
        """
        Y軸の範囲を適切な余白付きで設定する
        
        Args:
            ax (matplotlib.axes.Axes): 設定対象のAxesオブジェクト
            min_value (float): データの最小値
            max_value (float): データの最大値
            fixed_range_0_to_100 (bool): 0-100に設定するかどうか
        
        Returns:
            None
        
        Note:
            - fixed_range_0_to_100がtrueの場合は0-100で固定
            - 全て正の値の場合：maxの15%を上側余白として追加
            - 全て負の値の場合：minの15%を下側余白、上側に少しの余白
            - 正負混在の場合：それぞれに15%の余白を追加
        """
        print(f"max_value, min_value:{max_value, min_value}")

        # Y軸の範囲を設定
        if fixed_range_0_to_100:
            # trueの場合は0-100で固定
            ax.set_ylim(0, 100)
        else:
            data_range = max_value - min_value
            # 最小余白をデータ範囲の10%に設定
            min_margin = data_range * 0.1

            if min_value > 0:
                # 全て正の値：maxの15%を上側余白として追加
                margin = max_value * 0.15
                print(f"全て正の値：margin:{margin}")
                ax.set_ylim(top=max_value + margin)
            elif max_value < 0:
                # 全て負の値：minの15%を下側余白、上側に少しの余白
                margin = abs(min_value) * 0.15
                top_margin = abs(min_value) * 0.05
                print(f"全て負の値：margin:{margin}")
                ax.set_ylim(bottom=min_value - margin, top=top_margin)
            else:
                # 正負混在：それぞれに15%の余白を追加
                # max_value, min_valueが小さい場合、最小余白を保証
                top_margin = max(max_value * 0.15, min_margin)
                bottom_margin = max(abs(min_value) * 0.15, min_margin)
                print(f"正負混在：top_margin:{top_margin}, bottom_margin:{bottom_margin}")
                ax.set_ylim(bottom=min_value - bottom_margin, top=max_value + top_margin)

    def _prepare_yearsbar_colors(self, df, data, original_colors):
        """
        Yearsbar用の色を準備（GraphColorConfigとグラフ本数ルールを適用）

        Args:
            df: DataFrame
            data: グラフデータ
            original_colors: 元の色リスト

        Returns:
            list: 年数に応じた色リスト
        """
        # 実際の年数を取得（plot_years_bar()のロジックと同様）
        try:
            # Yearsbarの'Year'または'year'列から年データを取得
            year_column = None
            for col in df.columns:
                if col.lower() == 'year':
                    year_column = col
                    break

            if year_column is None:
                print(f"Debug: Yearsbar 'Year'カラムがDataFrameに存在しません")
                return original_colors

            # x軸のカラムデータを取得
            x_columns = data['x'].split(',')

            # 年ごとのデータを作成（plot_years_bar()と同様のロジック）
            years_data = {}
            for year in df[year_column].unique():
                data_values = df[df[year_column] == year][x_columns].iloc[0].tolist()
                data_values = [
                    pd.to_numeric(value, errors='coerce')
                    for value in data_values
                ]
                years_data[year] = data_values

            # 無効なデータを除外
            years_data = {
                year: values
                for year, values in years_data.items()
                if not (np.all(np.isnan(values)) or np.all(np.array(values) == 0))
            }

            num_years = len(years_data)

        except Exception as e:
            print(f"Debug: Yearsbar年数の取得でエラー: {e}")
            return original_colors

        print(f"Debug: Yearsbar年数={num_years}, 元の色={original_colors}")

        # GraphColorConfigの色を取得
        if hasattr(self, 'color_manager') and self.color_manager and self.color_manager.color_config:
            # 対応するitem_valを特定（main datasets + revised area datasets）
            item_val = None

            # まずself.datasetsから検索
            for key, dataset in self.datasets.items():
                try:
                    dataset_data = dataset if isinstance(dataset, list) else dataset.get('data', [])
                    if data in dataset_data:
                        item_val = int(key)
                        break
                except (ValueError, TypeError):
                    continue

            # self.datasetsで見つからない場合、self.revised_area_datasetsから検索
            if item_val is None and hasattr(self, 'revised_area_datasets'):
                for key, dataset in self.revised_area_datasets.items():
                    try:
                        dataset_data = dataset if isinstance(dataset, list) else dataset.get('data', [])
                        if data in dataset_data:
                            item_val = int(key)
                            break
                    except (ValueError, TypeError):
                        continue

            # item_valが見つかった場合、GraphColorConfigから色を取得
            if item_val is not None:
                custom_colors = self.color_manager.color_config.get(item_val, [])
                if custom_colors:
                    # グラフ本数ルールを適用
                    result_colors = self._get_colors_by_graph_count(custom_colors, num_years)
                    print(f"Debug: Yearsbar GraphColorConfig適用 item_val={item_val}, 結果={result_colors}")
                    return result_colors

        print(f"Debug: Yearsbar GraphColorConfig未適用, 元の色を使用={original_colors}")
        return original_colors

    def _get_colors_by_graph_count(self, custom_colors, graph_count):
        """
        グラフの本数に応じて適切な色を選択（GraphDock版）

        Args:
            custom_colors (list): カスタム色のリスト
            graph_count (int): グラフの本数

        Returns:
            list: 更新された色のリスト
        """
        result_colors = []

        if graph_count == 2:
            # 2本の場合：1つ目をスキップして2つ目・3つ目の色を使用
            for i in range(graph_count):
                color_index = (i + 1) % len(custom_colors)  # インデックス1から開始
                result_colors.append(custom_colors[color_index])
            print(f"Debug: 2本グラフ - 1つ目をスキップ: {result_colors}")

        elif graph_count == 3:
            # 3本の場合：そのまま1つ目・2つ目・3つ目の色を使用
            for i in range(graph_count):
                color_index = i % len(custom_colors)
                result_colors.append(custom_colors[color_index])
            print(f"Debug: 3本グラフ - そのまま適用: {result_colors}")

        else:
            # その他の本数の場合：通常の循環処理
            for i in range(graph_count):
                color_index = i % len(custom_colors)
                result_colors.append(custom_colors[color_index])
            print(f"Debug: {graph_count}本グラフ - 通常処理: {result_colors}")

        return result_colors

    @staticmethod
    def check_colors_yearsbar(years_data, colors):
        """
        Yearsbarのみにデフォルトと指定された色をマージする機能

        :param years_data: グラフのデータ（年ごとのデータ）。
        :type years_data: dict
        :param colors: 指定された色リスト。
        :type colors: list

        :returns: 色リスト（デフォルト色を含む）。
        :rtype: list
        """
        num_years = len(years_data)
        if not colors:
            return [
                _default_colors[i % len(_default_colors)]
                for i in range(num_years)
            ]
        while len(colors) < num_years:
            colors.append(_default_colors[len(colors) % len(_default_colors)])
        for i in range(num_years):
            if colors[i] == '':
                # 空文字列の場合のみデフォルト色で補完
                colors[i] = _default_colors[i % len(_default_colors)]
            # GraphColorConfigで設定された色は保護（_default_colorsにない色でも許可）

        return colors[:num_years]

    @staticmethod
    def get_max_value(dict_values):
        """
        最大の数値を見つける関数

        :param dict_values: 数値を含むリストまたは辞書。
        :type dict_values: list, dict

        :returns: 最大値。
        :rtype: float
        """
        try:
            if not hasattr(dict_values, '__iter__'):
                return 0

            max_value = float('-inf')
            for sublist in dict_values:
                if isinstance(sublist, (list, tuple)):
                    values = [
                        float(x) for x in sublist
                        if str(x).replace('.', '', 1).isdigit()
                    ]
                    if values:
                        max_value = max(max_value, *values)

            return max_value if max_value != float('-inf') else 0

        except Exception as e:
            print(f"Error processing dictionary values: {e}")
            return 0

    @staticmethod
    def get_min_value(dict_values):
        """
        最小の数値を見つける関数

        :param dict_values: 数値を含むリストまたは辞書。
        :type dict_values: list, dict

        :returns: 最小値。
        :rtype: float
        """
        try:
            if not hasattr(dict_values, '__iter__'):
                return 0

            min_value = float('inf')
            for sublist in dict_values:
                if isinstance(sublist, (list, tuple)):
                    values = []
                    for x in sublist:
                        try:
                            str_x = str(x).replace('-', '', 1)
                            if str_x.replace('.', '', 1).isdigit():
                                values.append(float(x))
                        except ValueError:
                            continue

                    if values:
                        min_value = min(min_value, *values)

            return min_value if min_value != float('inf') else 0

        except Exception as e:
            print(f"Error processing dictionary values: {e}")
            return 0

    def check_non_numeric_values(self, values):
        """
        リスト内の非数値の値をチェックする関数

        :param values: チェックする値のリスト。
        :type values: list

        :returns: リストに非数値が含まれている場合はTrue、そうでなければFalse。
        :rtype: bool
        """
        for value in values:
            if not isinstance(value, (int, float)):
                return True
        return False

    def add_solid_line(self, ax, bars, y_bases=None):
        """
        棒グラフに実線を追加する関数

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param bars: 実線を追加するバーのリスト。
        :type bars: list
        :param y_bases: 実線のy座標の基準（省略可能）。
        :type y_bases: list, optional

        :returns: 実線のy座標リスト。
        :rtype: list
        """
        if y_bases is None:
            y_bases = []
        return_list = []
        y2 = 0
        if len(y_bases) == 0:
            y_bases = [0 for i in range(len(bars))]
        for i in range(len(bars) - 1):
            current_bar = bars[i]
            next_bar = bars[i + 1]

            x1 = current_bar.get_x() + current_bar.get_width()
            y1 = y_bases[i] + current_bar.get_height()
            x2 = next_bar.get_x()
            y2 = y_bases[i + 1] + next_bar.get_height()
            ax.plot(
                [x1, x2], [y1, y2], color='grey', linestyle='-', linewidth=0.5
            )

            return_list.append(y1)
        return_list.append(y2)

        return return_list

    def add_dashed_line(self, ax, bars, y_bases=None):
        """
        棒グラフに破線を追加する関数

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param bars: 破線を追加するバーのリスト。
        :type bars: list
        :param y_bases: 破線のy座標の基準（省略可能）。
        :type y_bases: list, optional

        :returns: 破線のy座標リスト。
        :rtype: list
        """
        if y_bases is None:
            y_bases = []
        return_list = []
        y2 = 0
        if len(y_bases) == 0:
            y_bases = [0 for i in range(len(bars))]
        for i in range(len(bars) - 1):
            current_bar = bars[i]
            next_bar = bars[i + 1]

            x1 = current_bar.get_x() + current_bar.get_width()
            y1 = y_bases[i] + current_bar.get_height()
            x2 = next_bar.get_x()
            y2 = y_bases[i + 1] + next_bar.get_height()
            ax.plot([x1, x2], [y1, y2], 'k--', linewidth=0.5)

            return_list.append(y1)
        return_list.append(y2)

        return return_list
    
    def add_multiple_dashed_line(self, ax, bars):
        """
        積み上げグラフ(RelationBar)に破線を追加する関数

        :param ax: グラフを描画する軸。
        :type ax: matplotlib.axes.Axes
        :param bars: 破線を追加するバーのリスト。
        :type bars: list

        :returns: 破線のy座標リスト。
        :rtype: list
        """
        return_list = []
        
        group_num = len(bars)
        stuck_num = len(bars[0])

        for stuck in range(stuck_num):
            for i in range(group_num - 1):
                current_bar_container = bars[i][stuck]
                current_bar = current_bar_container[0]
                next_bar_container = bars[i+1][stuck]
                next_bar = next_bar_container[0]

                x1 = current_bar.get_x() + current_bar.get_width()
                y1 = current_bar.get_y() + current_bar.get_height()
                x2 = next_bar.get_x()
                y2 = next_bar.get_y() + next_bar.get_height()
                ax.plot([x1, x2], [y1, y2], 'k--', linewidth=0.5)

            return_list.append(y1)
        return_list.append(y2)

        return return_list

    def resizeEvent(self, event):
        """
        リサイズイベントを処理する関数

        :param event: イベント情報。
        :type event: QResizeEvent
        """
        super().resizeEvent(event)
        self.resize_timer.start(200)

    def adjust_figure_sizes(self):
        """ウィジェットのサイズに基づいて図のサイズを調整する関数"""
        # メイングラフタブのサイズ調整
        self._adjust_figures_in_layout(self.scroll_layout, self.scroll_area)

        # 修正区域タブがある場合のサイズ調整（title=0の場合のみ）
        if hasattr(self, 'revision_area_scroll_layout') and hasattr(self, 'revision_area_scroll_area'):
            self._adjust_figures_in_layout(self.revision_area_scroll_layout, self.revision_area_scroll_area)

    def _adjust_figures_in_layout(self, layout, scroll_area):
        """指定されたレイアウト内の図のサイズを調整する"""
        # 横スクロール対応のため、最小サイズを維持する
        viewport_width = scroll_area.viewport().width() - 20

        for i in range(layout.count()):
            item = layout.itemAt(i)
            if isinstance(item.widget(), FigureCanvas):
                canvas = item.widget()
                figure = canvas.figure

                # 横並びの場合はdata_groupからwide_layoutを確認
                data_group = getattr(canvas, 'data_group', None)
                if data_group:
                    has_wide_layout = any(self._get_wide_layout_flag(data) for data in data_group)
                    canvas_width, canvas_height, min_width = self._calculate_canvas_size(has_wide_layout, viewport_width)
                else:
                    # 単一グラフの場合（縦並び等）
                    data_info = getattr(canvas, 'data_info', None)
                    is_wide_layout = self._get_wide_layout_flag(data_info) if data_info else False
                    canvas_width, canvas_height, min_width = self._calculate_canvas_size(is_wide_layout, viewport_width)

                width_inches = canvas_width / figure.dpi
                height_inches = canvas_height / figure.dpi

                figure.set_size_inches(width_inches, height_inches)
                canvas.setFixedSize(canvas_width, canvas_height)
                self._adjust_legends_position(canvas)

                if min_width <= viewport_width:
                    figure.tight_layout()

                canvas.draw()

    def _get_default_canvas_size(self, canvas, viewport_width):
        """従来のキャンバスサイズ計算ロジック"""
        min_width = canvas.minimumWidth()
        min_height = canvas.minimumHeight()

        if min_width > viewport_width:
            canvas_width = min_width
            canvas_height = min_height
        else:
            canvas_width = viewport_width
            canvas_height = int(viewport_width * 3 / 4)

        return canvas_width, canvas_height

    def _parse_fixed_size(self, size_value):
        """XMLサイズ値を整数に変換"""
        if not size_value or size_value == '':
            return None
        try:
            return int(str(size_value).strip()) if size_value else None
        except (ValueError, TypeError):
            return None

    def _adjust_legends_position(self, canvas):
        """凡例の表示位置を調節する関数"""
        figure = canvas.figure
        axes = figure.get_axes()

        if not axes:
            return

        renderer = canvas.get_renderer()

        for ax in axes:
            legend = ax.get_legend()

            if not legend:
                continue

            x_axis_bbox = ax.xaxis.get_tightbbox(renderer)
            ax_bbox = ax.get_window_extent(renderer)

            if x_axis_bbox and ax_bbox:
                # axes座標系で計算
                # x軸の下端がaxesの下端から何ピクセル下にあるか
                x_axis_below_axes = ax_bbox.y0 - x_axis_bbox.y0

                # 凡例をx軸から2ピクセル下に配置
                margin_pixels = 2
                legend_position_below_axes = x_axis_below_axes + margin_pixels

                # axes座標系に変換（axesの高さで割る）
                legend_y = -legend_position_below_axes / ax_bbox.height
                legend.set_bbox_to_anchor((0.5, legend_y),
                                        transform=ax.transAxes)
            else:
                print("DEBUG: bbox not found")

    @staticmethod
    def parse_hatch(hatch: str) -> str | None:
        """
        XMLから取得したハッチ名を matplotlib のハッチパターンに変換する。
        :param hatch: 'cross', 'dot', 'horizontal', 'none'
        :return: 'xx', '..', '-', None
        """
        mapping = {
            "cross": "xx",
            "dot": "..",
            "horizontal": "-",
            "none": None
        }
        return mapping.get(hatch.lower(), None)

    def add_horizontal_lines(self, ax, data):
        """
        グラフに横線を追加する機能（範囲制御対応版）

        :param ax: matplotlib axes
        :type ax: matplotlib.axes.Axes
        :param data: グラフデータ（横線設定を含む）
        :type data: dict
        """
        # 横線設定が存在しない場合は何もしない
        hline_path = data.get('hline_path', '')
        hline_rate = data.get('hline_rate', [])

        if not hline_path or not hline_rate:
            return

        try:
            # 横線用CSVファイルを読み込み
            hline_df = pd.read_csv(hline_path)
            hline_rates = hline_rate
            hline_colors = data.get('hline_color', [])
            hline_ranges = data.get('hline_range', [])  # 新しい範囲設定

            # グラフのX軸範囲を取得
            x_min, x_max = ax.get_xlim()

            # X軸のデータポイント数を取得（棒グラフの場合）
            # グラフタイプに応じてX軸の区間数を判定
            x_data_points = self._get_x_data_points_count(ax, data)

            for i, rate_column in enumerate(hline_rates):
                rate_column = rate_column.strip()

                if rate_column and rate_column in hline_df.columns:
                    if len(hline_df) >= 1:
                        y_value = hline_df[rate_column].iloc[0]

                        try:
                            y_value = float(y_value)
                        except (ValueError, TypeError):
                            print(f"Warning: Invalid numeric value for {rate_column}: {y_value}")
                            continue

                        # 色の設定
                        color = 'gray'
                        if i < len(hline_colors) and hline_colors[i].strip():
                            color = hline_colors[i].strip()

                        # 横線の描画範囲を決定
                        line_x_min, line_x_max = self._calculate_hline_range(
                            i, hline_ranges, x_min, x_max, x_data_points
                        )

                        # 横線を描画
                        ax.hlines(y_value, line_x_min, line_x_max, 
                                colors=color, linestyles='dotted', linewidths=2)

        except Exception as e:
            print(f"Error adding horizontal lines: {e}")
            import traceback
            traceback.print_exc()

    def _get_x_data_points_count(self, ax, data):
        """
        グラフのX軸データポイント数を取得する

        :param ax: matplotlib axes
        :type ax: matplotlib.axes.Axes
        :param data: グラフデータ
        :type data: dict
        :return: X軸のデータポイント数
        :rtype: int
        """
        try:
            if 'path' in data and data['path']:
                df = pd.read_csv(data['path'])

                if data.get('type') == 'RelationBar' and 'x_pos' in data and data['x_pos']:
                    x_pos = data['x_pos']
                    if isinstance(x_pos, str):
                        count = len(x_pos.split(','))
                    else:
                        count = len(x_pos)
                    return count

                if 'x_label' in data and data['x_label']:
                    x_label_str = data['x_label']
                    if isinstance(x_label_str, str):
                        count = len(x_label_str.split(','))
                        return count

                if 'x_labels' in data and data['x_labels']:
                    x_labels = data['x_labels']
                    if isinstance(x_labels, list):
                        if len(x_labels) == 1 and (not x_labels[0] or x_labels[0].strip() == ''):
                            pass
                        else:
                            return len(x_labels)
                    elif isinstance(x_labels, str):
                        return len(x_labels.split(','))

                if data.get('type') == 'Yearsbar':
                    return 1
                else:
                    if 'x' in data and data['x']:
                        if ',' in data['x']:
                            x_columns = data['x'].split(',')
                            return len(x_columns)
                        elif data['x'] in df.columns:
                            return len(df[data['x']].unique())

            x_min, x_max = ax.get_xlim()
            count = int(x_max - x_min) if x_max > x_min else 1
            return count

        except Exception as e:
            return 1

    def _calculate_hline_range(self, line_index, hline_ranges, x_min, x_max, x_data_points):
        """
        横線の描画範囲を計算する

        :param line_index: 横線のインデックス（0から開始）
        :type line_index: int
        :param hline_ranges: 横線範囲設定のリスト
        :type hline_ranges: list
        :param x_min: X軸の最小値
        :type x_min: float
        :param x_max: X軸の最大値
        :type x_max: float
        :param x_data_points: X軸のデータポイント数
        :type x_data_points: int
        :return: (描画開始X座標, 描画終了X座標)
        :rtype: tuple[float, float]
        """
        if not hline_ranges or line_index >= len(hline_ranges):
            return x_min, x_max

        try:
            range_spec = hline_ranges[line_index].strip()
            if not range_spec:
                return x_min, x_max

            if '-' in range_spec:
                start_str, end_str = range_spec.split('-')
                start_point = int(start_str.strip())
                end_point = int(end_str.strip())
            else:
                start_point = end_point = int(range_spec.strip())

            start_point = max(1, start_point) - 1
            end_point = max(1, end_point) - 1

            start_point = max(0, min(start_point, x_data_points - 1))
            end_point = max(0, min(end_point, x_data_points - 1))

            if x_data_points > 1:
                point_width = (x_max - x_min) / x_data_points
                line_x_min = x_min + start_point * point_width
                line_x_max = x_min + (end_point + 1) * point_width
            else:
                line_x_min = x_min
                line_x_max = x_max

            return line_x_min, line_x_max

        except (ValueError, IndexError) as e:
            return x_min, x_max

    def add_text_box_with_line(self, ax, bar, text, layout = None):
        """
        バーからテキストボックスまでのラインとテキストボックスを追加

        :param ax: matplotlib axes
        :type ax: matplotlib.axes.Axes
        :param bar: 最終グループの第一積み上げグラフの情報
        :type bar: dict
        :param text: テキストボックスの情報
        :type text: dict
        :param layout: 表示するテキストの情報
        :type layout: dict
        """
        fontsize = text.get('fontsize', 10)
        text_string = text['text']
        bar_right = bar['bar_right']

        # フォントサイズから推定
        char_width_pixels = fontsize * 0.6
        padding_pixels = fontsize * 0.6 * 2
        text_width_pixels = len(text_string) * char_width_pixels + padding_pixels

        # ピクセル → data座標に変換
        fig_width_pixels = ax.figure.get_size_inches()[0] * ax.figure.dpi
        xlim = ax.get_xlim()
        x_range = xlim[1] - xlim[0]
        text_width_data = (text_width_pixels / fig_width_pixels) * x_range

        # gap と margin を計算
        gap = x_range * 0.01
        margin = x_range * 0.1

        # x軸を拡張
        new_right = bar_right + gap + text_width_data + margin
        ax.set_xlim(left=xlim[0], right=max(xlim[1], new_right))

        # テキストを中央に配置
        axes_right = ax.get_xlim()[1]
        text_x = (bar_right + axes_right) / 2

        # テキストボックスの左端を計算
        text_left = text_x - text_width_data / 2

        # ラインの終端 = テキストの左端より少し手前
        line_end_x = text_left - gap

        # 描画
        ax.text(text_x, bar['y'], text_string, ha='center',
                color=text.get('color', 'black'), fontsize=fontsize, bbox=text['bbox'])

        ax.hlines(y=bar['y'], xmin=bar['x'], xmax=line_end_x, **layout)

    def add_legends_with_line (self, ax, text, color):
        """
        RelationBarの凡例表示

        :param ax: matplotlib axes
        :type ax: matplotlib.axes.Axes
        :param height: RelationBarの最大積み上げ値
        :type height: int
        :param text: 凡例に表示するテキストのリスト
        :type text: list
        :param layout: 凡例に表示するラインの色リスト
        :type layout: list
        """
        # 凡例の数を取得
        legend_num = len(text)

        # 凡例を表示する列数を指定
        ncol = 2

        # 凡例の表示が列優先なので行優先に変更
        rows = (legend_num + ncol - 1) // ncol
        reordered = []

        for row in range(rows):
            for col in range(ncol):
                idx = col * rows + row
                if idx < legend_num:
                    reordered.append(idx)

        # ダミーラインの作成(凡例に表示するための描画処理)
        # 座標を指定していないので凡例以外には表示されない
        for i in reordered:
            ax.plot(
                [],
                [],
                color = color[i],
                linestyle=":",
                linewidth=2,
                label = text[i]
            )

        # 凡例の表示位置を取得
        xlim = ax.get_xlim()
        x = (xlim[1] + xlim[0]) / 2

        # データ座標→ディスプレイ座標→軸座標に変換(x座標のみ、y座標は使用しないので0)
        display_point = ax.transData.transform((x, 0))
        axes_point = ax.transAxes.inverted().transform(display_point)
        legend_x = axes_point[0]

        # 凡例の表示
        ax.legend(
            loc = 'upper center',
            bbox_to_anchor=(legend_x, -0.1),
            fontsize = 10,
            ncol = 2,
            frameon = True,
            handlelength=1.3, # 凡例のライン幅
            handletextpad=0.1, # 凡例のラインとラベルの間隔
            borderpad=0.5, # 凡例枠の余白
            columnspacing=0.3, # 凡例の列の間隔
        )

class MainGraphDock(GraphDock):
    """
    メイングラフ専用のDockWidget
    GraphDockから継承してメイングラフ機能のみを実装
    """
    def __init__(self, parent=None, translator=None):
        # GraphDockを継承し、title=2（新しい値）でメイングラフモードを指定
        super().__init__(parent, translator, title=2)
        self.setWindowTitle(self.tr('Graph: Current'))

    def setup_ui(self):
        """ユーザーインターフェースを設定します（メイングラフ専用）"""
        self.content = QWidget()
        self.layout = QVBoxLayout()
        self.content.setLayout(self.layout)
        self.setWidget(self.content)

        # メイングラフのスクロール領域のみを設定
        self.scroll_area = QScrollArea()
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout()
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.layout.addWidget(self.scroll_area)

        # データを初期化
        self.data_items, _, self.datasets = load_config(
            self.datalist_file, self.config_file, _config_file_custom
        )
        # GraphColorManagerを初期化
        self.color_manager = GraphColorManager(_color_file, True)
        # LayersColoringを初期化
        self.layer_coloring = LayersColoring()
        # 色をチェック・適用
        self.check_colors_with_custom_config()

    def update_plots_and_layer_coloring(self, data_item, year):
        """
        プロットとレイヤーの色を更新します
        :param data_item: 更新するデータ項目
        :type data_item: str
        :param year: 更新する年
        :type year: str
        """
        print(f"Debug: MainGraphDock - starting update_plots_and_layer_coloring")
        self.update_plots(data_item)
        print(f"Debug: MainGraphDock - update_plots completed, starting layer coloring")
        try:
            self.layer_coloring.coloring(data_item, year)
            print(f"Debug: MainGraphDock - layer coloring completed")
        except Exception as e:
            print(f"Debug: MainGraphDock - layer coloring failed: {e}")
        print(f"Debug: MainGraphDock - update_plots_and_layer_coloring completed")

    def adjust_figure_sizes(self):
        """グラフのサイズを調整します（メイングラフ用）"""
        # メイングラフのレイアウトのみを調整
        self._adjust_figures_in_layout(self.scroll_layout, self.scroll_area)

    def tr(self, message):
        """翻訳機能"""
        return QCoreApplication.translate('MainGraphDock', message)


class RevisedAreaGraphDock(GraphDock):
    """
    修正区域グラフ専用のDockWidget
    GraphDockから継承して修正区域グラフ機能のみを実装
    """
    def __init__(self, parent=None, translator=None):
        # GraphDockを継承し、title=3（新しい値）で修正区域グラフモードを指定
        super().__init__(parent, translator, title=3)
        self.setWindowTitle(self.tr('Graph: Revised Area'))

    def setup_ui(self):
        """ユーザーインターフェースを設定します（修正区域グラフ専用）"""
        self.content = QWidget()
        self.layout = QVBoxLayout()
        self.content.setLayout(self.layout)
        self.setWidget(self.content)

        # 修正区域グラフのスクロール領域のみを設定
        self.scroll_area = QScrollArea()
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout()
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.layout.addWidget(self.scroll_area)

        # データを初期化
        self.data_items, _, self.datasets = load_config(
            self.datalist_file, self.config_file, _config_file_custom
        )
        # 修正区域用の設定を読み込み
        self.revised_area_datasets = {}
        print(f"Debug: RevisedAreaGraphDock - Checking RevisedAreaVisualizationConfig.xml at: {_revised_area_config_file}")
        if os.path.exists(_revised_area_config_file):
            print(f"Debug: RevisedAreaGraphDock - RevisedAreaVisualizationConfig.xml exists, loading...")
            _, _, self.revised_area_datasets = load_config(
                self.datalist_file, _revised_area_config_file, None
            )
            print(f"Debug: RevisedAreaGraphDock - Loaded revised_area_datasets keys: {list(self.revised_area_datasets.keys())}")
            print(f"Debug: RevisedAreaGraphDock - Key types in revised_area_datasets: {[(k, type(k)) for k in self.revised_area_datasets.keys()]}")
            for key, value in self.revised_area_datasets.items():
                data_count = len(value.get('data', [])) if isinstance(value, dict) else len(value)
                print(f"Debug: RevisedAreaGraphDock - revised_area_datasets[{key}] = {type(value)} with {data_count} items")
        else:
            print(f"Debug: RevisedAreaGraphDock - RevisedAreaVisualizationConfig.xml does not exist, will use fallback")

        # GraphColorManagerを初期化
        self.color_manager = GraphColorManager(_color_file, True)
        # 色をチェック・適用
        self.check_colors_with_custom_config()

    def update_plots(self, data_item):
        """
        修正区域グラフのプロットを更新します
        :param data_item: 更新するデータ項目
        :type data_item: str
        """
        # 修正区域タブのレイアウトをクリア
        for i in reversed(range(self.scroll_layout.count())):
            self.scroll_layout.itemAt(i).widget().setParent(None)

        # 使用するデータセットを決定
        datasets_to_use = None
        target_layout = self.scroll_layout

        print(f"Debug: RevisedArea - data_item={data_item} (type: {type(data_item)})")
        print(f"Debug: RevisedArea - revised_area_datasets keys={list(self.revised_area_datasets.keys()) if hasattr(self, 'revised_area_datasets') else 'None'}")

        # キーの型変換を試行
        key_to_check = data_item
        if hasattr(self, 'revised_area_datasets') and self.revised_area_datasets:
            # data_itemが文字列の場合、数値キーとしても確認
            if isinstance(data_item, str) and data_item.isdigit():
                int_key = int(data_item)
                if int_key in self.revised_area_datasets:
                    key_to_check = int_key
                    print(f"Debug: revision area - found integer key {int_key}")
            # data_itemが数値の場合、文字列キーとしても確認
            elif isinstance(data_item, int):
                str_key = str(data_item)
                if str_key in self.revised_area_datasets:
                    key_to_check = str_key
                    print(f"Debug: revision area - found string key {str_key}")

        print(f"Debug: revision area - using key_to_check={key_to_check}")

        # current_item_valを設定（GraphColorManager用）
        try:
            self.current_item_val = int(data_item) if isinstance(data_item, (int, str)) else data_item
        except (ValueError, TypeError):
            self.current_item_val = data_item

        # 修正区域用の設定が存在し、かつ該当データがある場合
        if hasattr(self, 'revised_area_datasets') and self.revised_area_datasets and key_to_check in self.revised_area_datasets:
            datasets_to_use = self.revised_area_datasets
            print(f"Debug: revision area - using revised_area_datasets")
        # フォールバック：メイン設定からダミーデータセットを使用
        elif data_item:
            # 修正区域用のグラフは空のプロットを作成
            print(f"Debug: revision area - no specific dataset, creating empty plot")
            self.create_no_data_plot_for_revision_area()
            self.adjust_figure_sizes()
            return

        if datasets_to_use:
            dataset = datasets_to_use[key_to_check]
            print(f"Debug: revision area - found dataset for key {key_to_check}")
            # 新しい形式（辞書）か旧形式（リスト）かを判定
            if isinstance(dataset, dict):
                datalist = dataset.get('data', [])
                layout = dataset.get('layout', 'vertical')
                layout_config = dataset.get('layout_config', {'columns': 1, 'rows': 1})
            else:
                datalist = dataset
                layout = 'vertical'
                layout_config = {'columns': 1, 'rows': 1}
            # レイアウトに応じて表示方法を選択（修正区域用メソッドを使用）
            if layout == 'horizontal' and len(datalist) >= 1:
                self.create_horizontal_plots_for_revision_area(datalist, layout_config, target_layout)
            elif layout == 'mixed' and len(datalist) >= 1:
                self.create_mixed_plots_for_revision_area(datalist, layout_config, target_layout)
            else:
                self.create_vertical_plots_for_revision_area(datalist, target_layout)
        else:
            self.create_no_data_plot_for_revision_area()
        self.adjust_figure_sizes()

    def adjust_figure_sizes(self):
        """グラフのサイズを調整します（修正区域グラフ用）"""
        # 修正区域グラフのレイアウトのみを調整
        self._adjust_figures_in_layout(self.scroll_layout, self.scroll_area)

    def tr(self, message):
        """翻訳機能"""
        return QCoreApplication.translate('RevisedAreaGraphDock', message)
